<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-73KGWFC8DM"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());

            gtag('config', 'G-73KGWFC8DM');
        </script><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Heap Memory Debugging - ESP32 -  &mdash; ESP-IDF Programming Guide latest documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=a60756f2" />
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=949a1ff5" />
      <link rel="stylesheet" type="text/css" href="../../_static/theme_overrides.css?v=851bd809" />
      <link rel="stylesheet" type="text/css" href="../../_static/js/chatbot_widget.css?v=3106ea3a" />

  
    <link rel="canonical" href="https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/system/heap_debug.html" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=becddca3"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
        <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
        <script src="../../_static/copybutton.js?v=ff8fa330"></script>
        <script src="https://wavedrom.com/skins/default.js"></script>
        <script src="https://wavedrom.com/wavedrom.min.js"></script>
        <script src="../../_static/js/chatbot_widget_en.js?v=63d6728d"></script>
    <script src="../../_static/js/theme.js"></script>

    
        

    <script type="text/javascript">
        DOCUMENTATION_OPTIONS.PAGENAME = 'api-reference/system/heap_debug';
        DOCUMENTATION_OPTIONS.PROJECT_SLUG = 'esp-idf';
        DOCUMENTATION_OPTIONS.LATEST_BRANCH_NAME = 'master';
        DOCUMENTATION_OPTIONS.VERSIONS_URL = 'https://dl.espressif.com/dl/esp-idf/idf_versions.js';
        DOCUMENTATION_OPTIONS.LANGUAGES = ["en", "zh_CN"];
        DOCUMENTATION_OPTIONS.IDF_TARGET = 'esp32';
        DOCUMENTATION_OPTIONS.HAS_IDF_TARGETS = ["esp32", "esp32s2", "esp32s3", "esp32c3", "esp32c2", "esp32c5", "esp32c6", "esp32p4"]
        DOCUMENTATION_OPTIONS.RELEASE = 'latest';
        DOCUMENTATION_OPTIONS.LANGUAGE_URL = 'en';

    </script>

    <script type="text/javascript" src="https://dl.espressif.com/dl/esp-idf/idf_versions.js"></script>
    <link rel="author" title="About these documents" href="../../about.html" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="ESP Timer (High Resolution Timer)" href="esp_timer.html" />
    <link rel="prev" title="Memory Management for MMU Supported Memory" href="mm.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            ESP-IDF Programming Guide
              <img src="../../_static/espressif-logo.svg" class="logo" alt="Logo"/>
          </a>

          
            <div class="selectors">
              <select id="target-select" style="width: 150px;" hidden>
                <option value="" disabled selected>Choose target...</option>
              </select>
            </div>
          

          <div class="selectors">
            <select id="version-select" style="width: 150px;" hidden>
              <option value="" disabled selected>Choose version...</option>
            </select>
          </div>

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../get-started/index.html">Get Started</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">API Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../api-conventions.html">API Conventions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../protocols/index.html">Application Protocols</a></li>
<li class="toctree-l2"><a class="reference internal" href="../bluetooth/index.html">Bluetooth<sup>®</sup> API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../error-codes.html">Error Codes Reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="../network/index.html">Networking APIs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../peripherals/index.html">Peripherals API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../provisioning/index.html">Provisioning API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../storage/index.html">Storage API</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">System API</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="app_image_format.html">App Image Format</a></li>
<li class="toctree-l3"><a class="reference internal" href="bootloader_image_format.html">Bootloader Image Format</a></li>
<li class="toctree-l3"><a class="reference internal" href="app_trace.html">Application Level Tracing</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_function_with_shared_stack.html">Call Function with External Stack</a></li>
<li class="toctree-l3"><a class="reference internal" href="chip_revision.html">Chip Revision</a></li>
<li class="toctree-l3"><a class="reference internal" href="console.html">Console</a></li>
<li class="toctree-l3"><a class="reference internal" href="efuse.html">eFuse Manager</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_err.html">Error Code and Helper Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_https_ota.html">ESP HTTPS OTA</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_event.html">Event Loop Library</a></li>
<li class="toctree-l3"><a class="reference internal" href="freertos.html">FreeRTOS Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="freertos_idf.html">FreeRTOS (IDF)</a></li>
<li class="toctree-l3"><a class="reference internal" href="freertos_additions.html">FreeRTOS (Supplemental Features)</a></li>
<li class="toctree-l3"><a class="reference internal" href="mem_alloc.html">Heap Memory Allocation</a></li>
<li class="toctree-l3"><a class="reference internal" href="mm.html">Memory Management for MMU Supported Memory</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Heap Memory Debugging</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#heap-information">Heap Information</a></li>
<li class="toctree-l4"><a class="reference internal" href="#heap-allocation-and-free-function-hooks">Heap Allocation and Free Function Hooks</a></li>
<li class="toctree-l4"><a class="reference internal" href="#memory-allocation-failed-hook">Memory Allocation Failed Hook</a></li>
<li class="toctree-l4"><a class="reference internal" href="#heap-corruption-detection">Heap Corruption Detection</a></li>
<li class="toctree-l4"><a class="reference internal" href="#heap-task-tracking">Heap Task Tracking</a></li>
<li class="toctree-l4"><a class="reference internal" href="#heap-tracing">Heap Tracing</a></li>
<li class="toctree-l4"><a class="reference internal" href="#application-examples">Application Examples</a></li>
<li class="toctree-l4"><a class="reference internal" href="#api-referenceheap-task-tracking">API Reference–Heap Task Tracking</a></li>
<li class="toctree-l4"><a class="reference internal" href="#api-referenceheap-tracing">API Reference–Heap Tracing</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="esp_timer.html">ESP Timer (High Resolution Timer)</a></li>
<li class="toctree-l3"><a class="reference internal" href="internal-unstable.html">Internal and Unstable APIs</a></li>
<li class="toctree-l3"><a class="reference internal" href="ipc.html">Inter-Processor Call (IPC)</a></li>
<li class="toctree-l3"><a class="reference internal" href="intr_alloc.html">Interrupt Allocation</a></li>
<li class="toctree-l3"><a class="reference internal" href="log.html">Logging library</a></li>
<li class="toctree-l3"><a class="reference internal" href="misc_system_api.html">Miscellaneous System APIs</a></li>
<li class="toctree-l3"><a class="reference internal" href="ota.html">Over The Air Updates (OTA)</a></li>
<li class="toctree-l3"><a class="reference internal" href="perfmon.html">Performance Monitor</a></li>
<li class="toctree-l3"><a class="reference internal" href="power_management.html">Power Management</a></li>
<li class="toctree-l3"><a class="reference internal" href="pthread.html">POSIX Support (Including POSIX Threads Support)</a></li>
<li class="toctree-l3"><a class="reference internal" href="random.html">Random Number Generation</a></li>
<li class="toctree-l3"><a class="reference internal" href="sleep_modes.html">Sleep Modes</a></li>
<li class="toctree-l3"><a class="reference internal" href="soc_caps.html">SoC Capability Macros</a></li>
<li class="toctree-l3"><a class="reference internal" href="system_time.html">System Time</a></li>
<li class="toctree-l3"><a class="reference internal" href="himem.html">Himem</a></li>
<li class="toctree-l3"><a class="reference internal" href="ulp.html">Ultra Low Power (ULP) coprocessor</a></li>
<li class="toctree-l3"><a class="reference internal" href="wdts.html">Watchdogs</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../kconfig-reference.html">Configuration Options Reference</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../hw-reference/index.html">Hardware Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api-guides/index.html">API Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../migration-guides/index.html">Migration Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../libraries-and-frameworks/index.html">Libraries and Frameworks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contribute/index.html">Contributions Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../versions.html">ESP-IDF Versions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../resources.html">Resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../COPYRIGHT.html">Copyrights and Licenses</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../about.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../languages.html">Switch Between Languages</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">ESP-IDF Programming Guide</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">API Reference</a></li>
          <li class="breadcrumb-item"><a href="index.html">System API</a></li>
      <li class="breadcrumb-item active">Heap Memory Debugging</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/espressif/esp-idf/blob/758939ca/docs/en/api-reference/system/heap_debug.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="heap-memory-debugging">
<h1>Heap Memory Debugging<a class="headerlink" href="#heap-memory-debugging" title="Permalink to this heading"></a></h1>
<p><a class="reference external" href="../../../../../zh_CN/latest/esp32/api-reference/system/heap_debug.html">[中文]</a></p>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this heading"></a></h2>
<p>ESP-IDF integrates tools for requesting <a class="reference internal" href="#heap-information"><span class="std std-ref">heap information</span></a>, <a class="reference internal" href="#heap-corruption"><span class="std std-ref">heap corruption detection</span></a>, and <a class="reference internal" href="#heap-tracing"><span class="std std-ref">heap tracing</span></a>. These can help track down memory-related bugs.</p>
<p>For general information about the heap memory allocator, see <a class="reference internal" href="mem_alloc.html"><span class="doc">Heap Memory Allocation</span></a>.</p>
</section>
<section id="heap-information">
<span id="id1"></span><h2>Heap Information<a class="headerlink" href="#heap-information" title="Permalink to this heading"></a></h2>
<p>To obtain information about the state of the heap, call the following functions:</p>
<ul class="simple">
<li><p><a class="reference internal" href="mem_alloc.html#_CPPv423heap_caps_get_free_size8uint32_t" title="heap_caps_get_free_size"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_get_free_size()</span></code></a> can be used to return the current free memory for different memory capabilities.</p></li>
<li><p><a class="reference internal" href="mem_alloc.html#_CPPv432heap_caps_get_largest_free_block8uint32_t" title="heap_caps_get_largest_free_block"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_get_largest_free_block()</span></code></a> can be used to return the largest free block in the heap, which is also the largest single allocation currently possible. Tracking this value and comparing it to the total free heap allows you to detect heap fragmentation.</p></li>
<li><p><a class="reference internal" href="mem_alloc.html#_CPPv431heap_caps_get_minimum_free_size8uint32_t" title="heap_caps_get_minimum_free_size"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_get_minimum_free_size()</span></code></a> can be used to track the heap &quot;low watermark&quot; since boot.</p></li>
<li><p><a class="reference internal" href="mem_alloc.html#_CPPv418heap_caps_get_infoP17multi_heap_info_t8uint32_t" title="heap_caps_get_info"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_get_info()</span></code></a> returns a <a class="reference internal" href="mem_alloc.html#_CPPv417multi_heap_info_t" title="multi_heap_info_t"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">multi_heap_info_t</span></code></a> structure, which contains the information from the above functions, plus some additional heap-specific data (number of allocations, etc.).</p></li>
<li><p><a class="reference internal" href="mem_alloc.html#_CPPv425heap_caps_print_heap_info8uint32_t" title="heap_caps_print_heap_info"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_print_heap_info()</span></code></a> prints a summary of the information returned by <a class="reference internal" href="mem_alloc.html#_CPPv418heap_caps_get_infoP17multi_heap_info_t8uint32_t" title="heap_caps_get_info"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_get_info()</span></code></a> to stdout.</p></li>
<li><p><a class="reference internal" href="mem_alloc.html#_CPPv414heap_caps_dump8uint32_t" title="heap_caps_dump"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_dump()</span></code></a> and <a class="reference internal" href="mem_alloc.html#_CPPv418heap_caps_dump_allv" title="heap_caps_dump_all"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_dump_all()</span></code></a> output detailed information about the structure of each block in the heap. Note that this can be a large amount of output.</p></li>
</ul>
</section>
<section id="heap-allocation-and-free-function-hooks">
<span id="heap-allocation-free"></span><h2>Heap Allocation and Free Function Hooks<a class="headerlink" href="#heap-allocation-and-free-function-hooks" title="Permalink to this heading"></a></h2>
<p>Users can use allocation and free detection hooks to be notified of every successful allocation and free operation:</p>
<ul class="simple">
<li><p>Providing a definition of <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_heap_trace_alloc_hook()</span></code> allows you to be notified of every successful memory allocation operation.</p></li>
<li><p>Providing a definition of <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_heap_trace_free_hook()</span></code> allows you to be notified of every successful memory-free operations.</p></li>
</ul>
<p>This feature can be enabled by setting the <a class="reference internal" href="../kconfig-reference.html#config-heap-use-hooks"><span class="std std-ref">CONFIG_HEAP_USE_HOOKS</span></a> option. <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_heap_trace_alloc_hook()</span></code> and <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_heap_trace_free_hook()</span></code> have weak declarations (e.g., <code class="docutils literal notranslate"><span class="pre">__attribute__((weak))</span></code>), thus it is not necessary to provide declarations for both hooks. Given that it is technically possible to allocate and free memory from an ISR (<strong>though strongly discouraged from doing so</strong>), the <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_heap_trace_alloc_hook()</span></code> and <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_heap_trace_free_hook()</span></code> can potentially be called from an ISR.</p>
<p>It is not recommended to perform (or call API functions to perform) blocking operations or memory allocation/free operations in the hook functions. In general, the best practice is to keep the implementation concise and leave the heavy computation outside of the hook functions.</p>
<p>The example below shows how to define the allocation and free function hooks:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;esp_heap_caps.h&quot;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">esp_heap_trace_alloc_hook</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">caps</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">esp_heap_trace_free_hook</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">app_main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="memory-allocation-failed-hook">
<span id="heap-allocation-failed"></span><h2>Memory Allocation Failed Hook<a class="headerlink" href="#memory-allocation-failed-hook" title="Permalink to this heading"></a></h2>
<p>Users can use <a class="reference internal" href="mem_alloc.html#_CPPv440heap_caps_register_failed_alloc_callback23esp_alloc_failed_hook_t" title="heap_caps_register_failed_alloc_callback"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_register_failed_alloc_callback()</span></code></a> to register a callback that is invoked every time an allocation operation fails.</p>
<p>Additionally, users can enable the <a class="reference internal" href="../kconfig-reference.html#config-heap-abort-when-allocation-fails"><span class="std std-ref">CONFIG_HEAP_ABORT_WHEN_ALLOCATION_FAILS</span></a>, which will automatically trigger a system abort if any allocation operation fails.</p>
<p>The example below shows how to register an allocation failure callback:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;esp_heap_caps.h&quot;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">heap_caps_alloc_failed_hook</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">requested_size</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">caps</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">function_name</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s was called but failed to allocate %d bytes with 0x%X capabilities. </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">function_name</span><span class="p">,</span><span class="w"> </span><span class="n">requested_size</span><span class="p">,</span><span class="w"> </span><span class="n">caps</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">app_main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">    </span><span class="n">esp_err_t</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">heap_caps_register_failed_alloc_callback</span><span class="p">(</span><span class="n">heap_caps_alloc_failed_hook</span><span class="p">);</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">heap_caps_malloc</span><span class="p">(</span><span class="n">allocation_size</span><span class="p">,</span><span class="w"> </span><span class="n">MALLOC_CAP_DEFAULT</span><span class="p">);</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="heap-corruption-detection">
<span id="heap-corruption"></span><h2>Heap Corruption Detection<a class="headerlink" href="#heap-corruption-detection" title="Permalink to this heading"></a></h2>
<p>Heap corruption detection allows you to detect various types of heap memory errors:</p>
<ul class="simple">
<li><p>Out-of-bound writes &amp; buffer overflows</p></li>
<li><p>Writes to freed memory</p></li>
<li><p>Reads from freed or uninitialized memory</p></li>
</ul>
<p>Three levels of corruption detection are available. Each one providing a finer level of detection than the previous:</p>
<p><ul class="simple">
<li><p><a class="reference internal" href="#basic-no-poisoning">Basic (No Poisoning)</a></p></li>
<li><p><a class="reference internal" href="#light-impact">Light Impact</a></p></li>
<li><p><a class="reference internal" href="#comprehensive">Comprehensive</a></p></li>
</ul>
</p>
<section id="assertions">
<h3>Assertions<a class="headerlink" href="#assertions" title="Permalink to this heading"></a></h3>
<p>The heap implementation (<a class="reference external" href="https://github.com/espressif/esp-idf/blob/758939ca/components/heap/multi_heap.c">heap/multi_heap.c</a>, etc.) includes numerous assertions that will fail if the heap memory is corrupted. To detect heap corruption most effectively, ensure that assertions are enabled in the project configuration via the <a class="reference internal" href="../kconfig-reference.html#config-compiler-optimization-assertion-level"><span class="std std-ref">CONFIG_COMPILER_OPTIMIZATION_ASSERTION_LEVEL</span></a> option.</p>
<p>If a heap integrity assertion fails, a line will be printed like <code class="docutils literal notranslate"><span class="pre">CORRUPT</span> <span class="pre">HEAP:</span> <span class="pre">multi_heap.c:225</span> <span class="pre">detected</span> <span class="pre">at</span> <span class="pre">0x3ffbb71c</span></code>. The memory address printed is the address of the heap structure that has corrupt content.</p>
<p>It is also possible to manually check heap integrity by calling <a class="reference internal" href="mem_alloc.html#_CPPv429heap_caps_check_integrity_allb" title="heap_caps_check_integrity_all"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_check_integrity_all()</span></code></a> or related functions. This function checks all of the requested heap memory for integrity and can be used even if assertions are disabled. If the integrity checks detects an error, it will print the error along with the address(es) of corrupt heap structures.</p>
</section>
<section id="finding-heap-corruption">
<h3>Finding Heap Corruption<a class="headerlink" href="#finding-heap-corruption" title="Permalink to this heading"></a></h3>
<p>Memory corruption can be one of the hardest classes of bugs to find and fix, as the source of the corruption could be completely unrelated to the symptoms of the corruption. Here are some tips:</p>
<ul class="simple">
<li><p>A crash with a <code class="docutils literal notranslate"><span class="pre">CORRUPT</span> <span class="pre">HEAP:</span></code> message usually includes a stack trace, but this stack trace is rarely useful. The crash is the symptom of memory corruption when the system realizes the heap is corrupt. But usually, the corruption happens elsewhere and earlier in time.</p></li>
<li><p>Increasing the heap memory debugging <a class="reference internal" href="#configuration">Configuration</a> level to &quot;Light impact&quot; or &quot;Comprehensive&quot; gives you a more accurate message with the first corrupt memory address.</p></li>
<li><p>Adding regular calls to <a class="reference internal" href="mem_alloc.html#_CPPv429heap_caps_check_integrity_allb" title="heap_caps_check_integrity_all"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_check_integrity_all()</span></code></a> or <a class="reference internal" href="mem_alloc.html#_CPPv430heap_caps_check_integrity_addr8intptr_tb" title="heap_caps_check_integrity_addr"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_check_integrity_addr()</span></code></a> in your code helps you pin down the exact time that the corruption happened. You can move these checks around to &quot;close in on&quot; the section of code that corrupted the heap.</p></li>
<li><p>Based on the memory address that has been corrupted, you can use <a class="reference internal" href="../../api-guides/jtag-debugging/index.html#jtag-debugging-introduction"><span class="std std-ref">JTAG debugging</span></a> to set a watchpoint on this address and have the CPU halt when it is written to.</p></li>
<li><p>If you do not have JTAG, but you do know roughly when the corruption happens, set a watchpoint in software just beforehand via <a class="reference internal" href="misc_system_api.html#_CPPv422esp_cpu_set_watchpointiPKv6size_t28esp_cpu_watchpoint_trigger_t" title="esp_cpu_set_watchpoint"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_cpu_set_watchpoint()</span></code></a>. A fatal exception will occur when the watchpoint triggers. The following is an example of how to use the function - <code class="docutils literal notranslate"><span class="pre">esp_cpu_set_watchpoint(0,</span> <span class="pre">(void</span> <span class="pre">*)addr,</span> <span class="pre">4,</span> <span class="pre">ESP_WATCHPOINT_STORE)</span></code>. Note that watchpoints are per-CPU and are set on the current running CPU only. So if you do not know which CPU is corrupting memory, call this function on both CPUs.</p></li>
<li><p>For buffer overflows, <a class="reference internal" href="#id3">heap tracing</a> in <code class="docutils literal notranslate"><span class="pre">HEAP_TRACE_ALL</span></code> mode tells which callers are allocating which addresses from the heap. See <a class="reference internal" href="#heap-tracing-to-find-heap-corruption">Heap Tracing To Find Heap Corruption</a> for more details. You can try to find the function that allocates memory with an address immediately before the corrupted address, since it is probably the function that overflows the buffer.</p></li>
<li><p>Calling <a class="reference internal" href="mem_alloc.html#_CPPv414heap_caps_dump8uint32_t" title="heap_caps_dump"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_dump()</span></code></a> or <a class="reference internal" href="mem_alloc.html#_CPPv418heap_caps_dump_allv" title="heap_caps_dump_all"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_dump_all()</span></code></a> can give an indication of what heap blocks are surrounding the corrupted region and may have overflowed or underflowed, etc.</p></li>
</ul>
</section>
<section id="configuration">
<h3>Configuration<a class="headerlink" href="#configuration" title="Permalink to this heading"></a></h3>
<p>Temporarily increasing the heap corruption detection level can give more detailed information about heap corruption errors.</p>
<p>In the project configuration menu, under <code class="docutils literal notranslate"><span class="pre">Component</span> <span class="pre">config</span></code>, there is a menu <code class="docutils literal notranslate"><span class="pre">Heap</span> <span class="pre">memory</span> <span class="pre">debugging</span></code>. The option <a class="reference internal" href="../kconfig-reference.html#config-heap-corruption-detection"><span class="std std-ref">CONFIG_HEAP_CORRUPTION_DETECTION</span></a> can be set to one of the following three levels:</p>
<section id="basic-no-poisoning">
<h4>Basic (No Poisoning)<a class="headerlink" href="#basic-no-poisoning" title="Permalink to this heading"></a></h4>
<p>This is the default level. By default, no special heap corruption features are enabled, but the provided assertions are enabled. A heap corruption error will be printed if any of the heap's internal data structures appear overwritten or corrupted. This usually indicates a buffer overrun or out-of-bounds write.</p>
<p>If assertions are enabled, an assertion will also trigger if a double-free occurs (the same memory is freed twice).</p>
<p>Calling <a class="reference internal" href="mem_alloc.html#_CPPv425heap_caps_check_integrity8uint32_tb" title="heap_caps_check_integrity"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_check_integrity()</span></code></a> in Basic mode checks the integrity of all heap structures, and print errors if any appear to be corrupted.</p>
</section>
<section id="light-impact">
<h4>Light Impact<a class="headerlink" href="#light-impact" title="Permalink to this heading"></a></h4>
<p>This level incorporates the &quot;Basic&quot; detection features. Additionally, each block of memory allocated is &quot;poisoned&quot; with head and tail &quot;canary bytes&quot;. If an application writes over the &quot;canary bytes&quot;, they will be seen as corrupted and integrity checks will fail.</p>
<p>The head canary word is <code class="docutils literal notranslate"><span class="pre">0xABBA1234</span></code> (<code class="docutils literal notranslate"><span class="pre">3412BAAB</span></code> in byte order), and the tail canary word is <code class="docutils literal notranslate"><span class="pre">0xBAAD5678</span></code> (<code class="docutils literal notranslate"><span class="pre">7856ADBA</span></code> in byte order).</p>
<p>With basic heap corruption checks, most out-of-bound writes can be detected and the number of overrun bytes before a failure is detected depends on the properties of the heap. However, the Light Impact mode is more precise as even a single-byte overrun can be detected.</p>
<p>Enabling light-impact checking increases the memory usage since each individual allocation uses additional bytes of metadata.</p>
<p>Each time <a class="reference internal" href="mem_alloc.html#_CPPv414heap_caps_freePv" title="heap_caps_free"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_free()</span></code></a> is called in Light Impact mode, the head and tail canary bytes of the buffer being freed are checked against the expected values.</p>
<p>When <a class="reference internal" href="mem_alloc.html#_CPPv425heap_caps_check_integrity8uint32_tb" title="heap_caps_check_integrity"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_check_integrity()</span></code></a> or <a class="reference internal" href="mem_alloc.html#_CPPv429heap_caps_check_integrity_allb" title="heap_caps_check_integrity_all"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_check_integrity_all()</span></code></a> is called, all allocated blocks of heap memory have their canary bytes checked against the expected values.</p>
<p>In both cases, the functions involve checking that the first 4 bytes of an allocated block (before the buffer is returned to the user) should be the word <code class="docutils literal notranslate"><span class="pre">0xABBA1234</span></code>, and the last 4 bytes of the allocated block (after the buffer is returned to the user) should be the word <code class="docutils literal notranslate"><span class="pre">0xBAAD5678</span></code>.</p>
<p>Different values usually indicate buffer underrun or overrun. Overrun indicates that when writing to memory, the data written exceeds the size of the allocated memory, resulting in writing to an unallocated memory area; underrun indicates that when reading memory, the data read exceeds the allocated memory and reads data from an unallocated memory area.</p>
</section>
<section id="comprehensive">
<h4>Comprehensive<a class="headerlink" href="#comprehensive" title="Permalink to this heading"></a></h4>
<p>This level incorporates the &quot;Light Impact&quot; detection features. Additionally, it checks for uninitialized-access and use-after-free bugs. In this mode, all freshly allocated memory is filled with the pattern <code class="docutils literal notranslate"><span class="pre">0xCE</span></code>, and all freed memory is filled with the pattern <code class="docutils literal notranslate"><span class="pre">0xFE</span></code>.</p>
<p>Enabling Comprehensive mode has a substantial impact on runtime performance, as all memory needs to be set to the allocation patterns each time a <a class="reference internal" href="mem_alloc.html#_CPPv416heap_caps_malloc6size_t8uint32_t" title="heap_caps_malloc"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_malloc()</span></code></a> or <a class="reference internal" href="mem_alloc.html#_CPPv414heap_caps_freePv" title="heap_caps_free"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_free()</span></code></a> completes, and the memory also needs to be checked each time. However, this mode allows easier detection of memory corruptions which are much more subtle to find otherwise. It is recommended to only enable this mode when debugging, not in production.</p>
<p>The checks for allocated and free patterns (<code class="docutils literal notranslate"><span class="pre">0xCE</span></code> and <code class="docutils literal notranslate"><span class="pre">0xFE</span></code>, respectively) are also done when calling <a class="reference internal" href="mem_alloc.html#_CPPv425heap_caps_check_integrity8uint32_tb" title="heap_caps_check_integrity"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_check_integrity()</span></code></a> or <a class="reference internal" href="mem_alloc.html#_CPPv429heap_caps_check_integrity_allb" title="heap_caps_check_integrity_all"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_check_integrity_all()</span></code></a>.</p>
<section id="crashes-in-comprehensive-mode">
<h5>Crashes in Comprehensive Mode<a class="headerlink" href="#crashes-in-comprehensive-mode" title="Permalink to this heading"></a></h5>
<p>If an application crashes when reading or writing an address related to <code class="docutils literal notranslate"><span class="pre">0xCECECECE</span></code> in Comprehensive mode, it indicates that it has read uninitialized memory. The application should be changed to either use <a class="reference internal" href="mem_alloc.html#_CPPv416heap_caps_calloc6size_t6size_t8uint32_t" title="heap_caps_calloc"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_calloc()</span></code></a> (which zeroes memory), or initialize the memory before using it. The value <code class="docutils literal notranslate"><span class="pre">0xCECECECE</span></code> may also be seen in stack-allocated automatic variables, because, in ESP-IDF, most task stacks are originally allocated from the heap, and in C, stack memory is uninitialized by default.</p>
<p>If an application crashes, and the exception register dump indicates that some addresses or values were <code class="docutils literal notranslate"><span class="pre">0xFEFEFEFE</span></code>, this indicates that it is reading heap memory after it has been freed, i.e., a &quot;use-after-free bug&quot;. The application should be changed to not access heap memory after it has been freed.</p>
<p>If a call to <a class="reference internal" href="mem_alloc.html#_CPPv416heap_caps_malloc6size_t8uint32_t" title="heap_caps_malloc"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_malloc()</span></code></a> or <a class="reference internal" href="mem_alloc.html#_CPPv417heap_caps_reallocPv6size_t8uint32_t" title="heap_caps_realloc"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_realloc()</span></code></a> causes a crash because it was expected to find the pattern <code class="docutils literal notranslate"><span class="pre">0xFEFEFEFE</span></code> in free memory and a different pattern was found, it indicates that the app has a use-after-free bug where it is writing to memory that has already been freed.</p>
</section>
<section id="manual-heap-checks-in-comprehensive-mode">
<h5>Manual Heap Checks in Comprehensive Mode<a class="headerlink" href="#manual-heap-checks-in-comprehensive-mode" title="Permalink to this heading"></a></h5>
<p>Calls to <a class="reference internal" href="mem_alloc.html#_CPPv425heap_caps_check_integrity8uint32_tb" title="heap_caps_check_integrity"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_check_integrity()</span></code></a> or <a class="reference internal" href="mem_alloc.html#_CPPv429heap_caps_check_integrity_allb" title="heap_caps_check_integrity_all"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_check_integrity_all()</span></code></a> may print errors relating to <code class="docutils literal notranslate"><span class="pre">0xFEFEFEFE</span></code>, <code class="docutils literal notranslate"><span class="pre">0xABBA1234</span></code>, or <code class="docutils literal notranslate"><span class="pre">0xBAAD5678</span></code>. In each case the checker is expected to find a given pattern, and will error out if not found:</p>
<ul class="simple">
<li><p>For free heap blocks, the checker expects to find all bytes set to <code class="docutils literal notranslate"><span class="pre">0xFE</span></code>. Any other values indicate a use-after-free bug where free memory has been incorrectly overwritten.</p></li>
<li><p>For allocated heap blocks, the behavior is the same as for the Light Impact mode. The canary bytes <code class="docutils literal notranslate"><span class="pre">0xABBA1234</span></code> and <code class="docutils literal notranslate"><span class="pre">0xBAAD5678</span></code> are checked at the head and tail of each allocated buffer, and any variation indicates a buffer overrun or underrun.</p></li>
</ul>
</section>
</section>
</section>
</section>
<section id="heap-task-tracking">
<span id="id2"></span><h2>Heap Task Tracking<a class="headerlink" href="#heap-task-tracking" title="Permalink to this heading"></a></h2>
<p>The Heap Task Tracking can be enabled via the menuconfig: <code class="docutils literal notranslate"><span class="pre">Component</span> <span class="pre">config</span></code> &gt; <code class="docutils literal notranslate"><span class="pre">Heap</span> <span class="pre">memory</span> <span class="pre">debugging</span></code> &gt; <code class="docutils literal notranslate"><span class="pre">Enable</span> <span class="pre">heap</span> <span class="pre">task</span> <span class="pre">tracking</span></code> (see <a class="reference internal" href="../kconfig-reference.html#config-heap-task-tracking"><span class="std std-ref">CONFIG_HEAP_TASK_TRACKING</span></a>).</p>
<p>The feature allows users to track the heap memory usage of each task created since startup and provides a series of statistics that can be accessed via getter functions or simply dumped into the stream of the user's choosing. This feature is useful for identifying memory usage patterns and potential memory leaks.</p>
<p>An additional configuration can be enabled by the user via the menuconfig: <code class="docutils literal notranslate"><span class="pre">Component</span> <span class="pre">config</span></code> &gt; <code class="docutils literal notranslate"><span class="pre">Heap</span> <span class="pre">memory</span> <span class="pre">debugging</span></code> &gt; <code class="docutils literal notranslate"><span class="pre">Keep</span> <span class="pre">information</span> <span class="pre">about</span> <span class="pre">the</span> <span class="pre">memory</span> <span class="pre">usage</span> <span class="pre">of</span> <span class="pre">deleted</span> <span class="pre">tasks</span></code> (see <a class="reference internal" href="../kconfig-reference.html#config-heap-track-deleted-tasks"><span class="std std-ref">CONFIG_HEAP_TRACK_DELETED_TASKS</span></a>) to keep the statistics collected for a given task even after it is deleted.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Note that the Heap Task Tracking cannot detect the deletion of statically allocated tasks. Therefore, users will have to keep in mind while reading the following section that statically allocated tasks will always be considered alive in the scope of the Heap Task Tracking feature.</p>
</div>
<p>It is important to mention that its usage is strongly discouraged for other purposes than debugging for the following reasons:</p>
<p><ul class="simple">
<li><p>Tracking the allocations and storing the resulting statistics for each task requires a non-negligible RAM usage overhead.</p></li>
<li><p>The overall performance of the heap allocator is severely impacted due to the additional processing required for each allocation and free operation.</p></li>
</ul>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Note that the memory allocated by the heap task tracking feature will not be visible when dumping or accessing the statistics.</p>
</div>
<section id="structure-of-the-statistics-and-information">
<h3>Structure of the Statistics And Information<a class="headerlink" href="#structure-of-the-statistics-and-information" title="Permalink to this heading"></a></h3>
<p>For a given task, the heap task tracking feature categorizes statistics on three different levels:</p>
<p><ul class="simple">
<li><p>The task level statistics</p></li>
<li><p>The heap level statistics</p></li>
<li><p>The allocation level statistics</p></li>
</ul>
</p>
<p>The task level statistics provides the following information:</p>
<p><ul class="simple">
<li><p>Name of the given task</p></li>
<li><p>Task handle of the given task</p></li>
<li><p>Status of the given task (if the task is running or deleted)</p></li>
<li><p>Peak memory usage of the given task (the maximum amount of memory used by the given task during the task lifetime)</p></li>
<li><p>Current memory usage of the given task</p></li>
<li><p>Number of heaps in which the task has allocated memory</p></li>
</ul>
</p>
<p>The heap level statistics provides the following information for each heap used by the given task:</p>
<p><ul class="simple">
<li><p>Name of the given heap</p></li>
<li><p>Capabilities of the given heap (without priority)</p></li>
<li><p>Total size of the given heap</p></li>
<li><p>Current usage of the given task on the given heap</p></li>
<li><p>Peak usage of the given task on the given heap</p></li>
<li><p>Number of allocations done by the given task for on the given heap</p></li>
</ul>
</p>
<p>The allocation level statistics provides the following information for each allocation done by the given task on the given heap:</p>
<p><ul class="simple">
<li><p>Address of the given allocation</p></li>
<li><p>Size of the given allocation</p></li>
</ul>
</p>
</section>
<section id="dumping-the-statistics-and-information">
<h3>Dumping the Statistics And Information<a class="headerlink" href="#dumping-the-statistics-and-information" title="Permalink to this heading"></a></h3>
<p>The <a class="reference internal" href="#_CPPv441heap_caps_print_single_task_stat_overviewP4FILE12TaskHandle_t" title="heap_caps_print_single_task_stat_overview"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_print_single_task_stat_overview()</span></code></a> API prints an overview of heap usage for a specific task to the provided output stream.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>┌────────────────────┬─────────┬──────────────────────┬───────────────────┬─────────────────┐
│ TASK               │ STATUS  │ CURRENT MEMORY USAGE │ PEAK MEMORY USAGE │ TOTAL HEAP USED │
├────────────────────┼─────────┼──────────────────────┼───────────────────┼─────────────────┤
│          task_name │ ALIVE   │                    0 │              7152 │               1 │
└────────────────────┴─────────┴──────────────────────┴───────────────────┴─────────────────┘
</pre></div>
</div>
<p><a class="reference internal" href="#_CPPv438heap_caps_print_all_task_stat_overviewP4FILE" title="heap_caps_print_all_task_stat_overview"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_print_all_task_stat_overview()</span></code></a> prints an overview of heap usage for all tasks (including the deleted tasks if <a class="reference internal" href="../kconfig-reference.html#config-heap-track-deleted-tasks"><span class="std std-ref">CONFIG_HEAP_TRACK_DELETED_TASKS</span></a> is enabled).</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>┌────────────────────┬─────────┬──────────────────────┬───────────────────┬─────────────────┐
│ TASK               │ STATUS  │ CURRENT MEMORY USAGE │ PEAK MEMORY USAGE │ TOTAL HEAP USED │
├────────────────────┼─────────┼──────────────────────┼───────────────────┼─────────────────┤
│          task_name │ DELETED │                11392 │             11616 │               1 │
│    other_task_name │ ALIVE   │                    0 │              9408 │               2 │
│               main │ ALIVE   │                 3860 │              7412 │               2 │
│               ipc1 │ ALIVE   │                   32 │                44 │               1 │
│               ipc0 │ ALIVE   │                10080 │             10092 │               1 │
│      Pre-scheduler │ ALIVE   │                 2236 │              2236 │               1 │
└────────────────────┴─────────┴──────────────────────┴───────────────────┴─────────────────┘
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Note that the task named &quot;Pre-scheduler&quot; represents allocations that occurred before the scheduler was started. It is not an actual task, so the &quot;status&quot; field (which is shown as &quot;ALIVE&quot;) is not meaningful and should be ignored.</p>
</div>
<p>Use <a class="reference internal" href="#_CPPv432heap_caps_print_single_task_statP4FILE12TaskHandle_t" title="heap_caps_print_single_task_stat"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_print_single_task_stat()</span></code></a> to dump the complete set of statistics for a specific task, or <a class="reference internal" href="#_CPPv429heap_caps_print_all_task_statP4FILE" title="heap_caps_print_all_task_stat"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_print_all_task_stat()</span></code></a> to dump statistics for all tasks:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>[...]
├ ALIVE: main, CURRENT MEMORY USAGE 308, PEAK MEMORY USAGE 7412, TOTAL HEAP USED 2:
│    ├ HEAP: RAM, CAPS: 0x0010580e, SIZE: 344400, USAGE: CURRENT 220 (0%), PEAK 220 (0%), ALLOC COUNT: 2
│    │    ├ ALLOC 0x3fc99024, SIZE 88
│    │    ├ ALLOC 0x3fc99124, SIZE 132
│    └ HEAP: RAM, CAPS: 0x0010580e, SIZE: 22308, USAGE: CURRENT 88 (0%), PEAK 7192 (32%), ALLOC COUNT: 5
│         ├ ALLOC 0x3fce99f8, SIZE 20
│         ├ ALLOC 0x3fce9a10, SIZE 12
│         ├ ALLOC 0x3fce9a20, SIZE 16
│         ├ ALLOC 0x3fce9a34, SIZE 20
│         ├ ALLOC 0x3fce9a4c, SIZE 20
[...]
└ ALIVE: Pre-scheduler, CURRENT MEMORY USAGE 2236, PEAK MEMORY USAGE 2236, TOTAL HEAP USED 1:
    └ HEAP: RAM, CAPS: 0x0010580e, SIZE: 344400, USAGE: CURRENT 2236 (0%), PEAK 2236 (0%), ALLOC COUNT: 11
          ├ ALLOC 0x3fc95cb0, SIZE 164
          ├ ALLOC 0x3fc95dd8, SIZE 12
          ├ ALLOC 0x3fc95dfc, SIZE 12
          ├ ALLOC 0x3fc95e20, SIZE 16
          ├ ALLOC 0x3fc95e48, SIZE 24
          ├ ALLOC 0x3fc95e78, SIZE 88
          ├ ALLOC 0x3fc95ee8, SIZE 88
          ├ ALLOC 0x3fc95f58, SIZE 88
          ├ ALLOC 0x3fc95fc8, SIZE 88
          ├ ALLOC 0x3fc96038, SIZE 1312
          ├ ALLOC 0x3fc96570, SIZE 344
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The dump shown above has been truncated (see &quot;[...]&quot;) for readability reasons and only displays the statistics and information of the <strong>main</strong> task and the <strong>Pre-scheduler</strong>. The goal here is only to demonstrate the information displayed when calling the <a class="reference internal" href="#_CPPv429heap_caps_print_all_task_statP4FILE" title="heap_caps_print_all_task_stat"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_print_all_task_stat()</span></code></a> (resp. <a class="reference internal" href="#_CPPv432heap_caps_print_single_task_statP4FILE12TaskHandle_t" title="heap_caps_print_single_task_stat"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_print_single_task_stat()</span></code></a>) API functions.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Detailed use of the API functions described in this section can be found in <a class="reference external" href="https://github.com/espressif/esp-idf/tree/758939ca/examples/system/heap_task_tracking/basic">system/heap_task_tracking/basic</a>.</p>
</div>
</section>
<section id="getting-the-statistics-and-information">
<h3>Getting the Statistics And Information<a class="headerlink" href="#getting-the-statistics-and-information" title="Permalink to this heading"></a></h3>
<p><a class="reference internal" href="#_CPPv430heap_caps_get_single_task_statP23heap_single_task_stat_t12TaskHandle_t" title="heap_caps_get_single_task_stat"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_get_single_task_stat()</span></code></a> allows the user to access information of a specific task. The information retrieved by calling this API is identical to the one dumped using <a class="reference internal" href="#_CPPv432heap_caps_print_single_task_statP4FILE12TaskHandle_t" title="heap_caps_print_single_task_stat"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_print_single_task_stat()</span></code></a>.</p>
<p><a class="reference internal" href="#_CPPv427heap_caps_get_all_task_statP21heap_all_tasks_stat_t" title="heap_caps_get_all_task_stat"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_get_all_task_stat()</span></code></a> allows the user to access an overview of the information of all tasks (including the deleted tasks if <a class="reference internal" href="../kconfig-reference.html#config-heap-track-deleted-tasks"><span class="std std-ref">CONFIG_HEAP_TRACK_DELETED_TASKS</span></a> is enabled). The information retrieved by calling this API is identical to the one dumped using <a class="reference internal" href="#_CPPv429heap_caps_print_all_task_statP4FILE" title="heap_caps_print_all_task_stat"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_print_all_task_stat()</span></code></a>.</p>
<p>Each getter function requires a pointer to the data structure that will be used by the heap task tracking to gather the statistics and information of a given task (or all tasks). This data structure contains pointers to arrays that the user can allocate statically or dynamically.</p>
<p>The size of the arrays used to store information is difficult to estimate. Examples include the number of allocations per task, the number of heaps used by each task, and the number of tasks created since startup. Therefore, the heap task tracking also provides <a class="reference internal" href="#_CPPv439heap_caps_alloc_single_task_stat_arraysP23heap_single_task_stat_t12TaskHandle_t" title="heap_caps_alloc_single_task_stat_arrays"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_alloc_single_task_stat_arrays()</span></code></a> (resp. <a class="reference internal" href="#_CPPv436heap_caps_alloc_all_task_stat_arraysP21heap_all_tasks_stat_t" title="heap_caps_alloc_all_task_stat_arrays"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_alloc_all_task_stat_arrays()</span></code></a>) to dynamically allocate the required amount of memory for those arrays.</p>
<p>Similarly, the heap task tracking also provides <a class="reference internal" href="#_CPPv438heap_caps_free_single_task_stat_arraysP23heap_single_task_stat_t" title="heap_caps_free_single_task_stat_arrays"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_free_single_task_stat_arrays()</span></code></a> (resp. <a class="reference internal" href="#_CPPv435heap_caps_free_all_task_stat_arraysP21heap_all_tasks_stat_t" title="heap_caps_free_all_task_stat_arrays"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_free_all_task_stat_arrays()</span></code></a>) to free the memory dynamically allocated when calling <a class="reference internal" href="#_CPPv439heap_caps_alloc_single_task_stat_arraysP23heap_single_task_stat_t12TaskHandle_t" title="heap_caps_alloc_single_task_stat_arrays"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_alloc_single_task_stat_arrays()</span></code></a> (resp. <a class="reference internal" href="#_CPPv436heap_caps_alloc_all_task_stat_arraysP21heap_all_tasks_stat_t" title="heap_caps_alloc_all_task_stat_arrays"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_alloc_all_task_stat_arrays()</span></code></a>).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Detailed use of the API functions described in this section can be found in <a class="reference external" href="https://github.com/espressif/esp-idf/tree/758939ca/examples/system/heap_task_tracking/advanced">system/heap_task_tracking/advanced</a>.</p>
</div>
</section>
</section>
<section id="heap-tracing">
<span id="id3"></span><h2>Heap Tracing<a class="headerlink" href="#heap-tracing" title="Permalink to this heading"></a></h2>
<p>Heap Tracing allows the tracing of code which allocates or frees memory. Two tracing modes are supported:</p>
<ul class="simple">
<li><p>Standalone. In this mode, traced data are kept on-board, so the size of the gathered information is limited by the buffer assigned for that purpose, and the analysis is done by the on-board code. There are a couple of APIs available for accessing and dumping collected info.</p></li>
<li><p>Host-based. This mode does not have the limitation of the standalone mode, because traced data are sent to the host over JTAG connection using app_trace library. Later on, they can be analyzed using special tools.</p></li>
</ul>
<p>Heap tracing can perform two functions:</p>
<ul class="simple">
<li><p>Leak checking: find memory that is allocated and never freed.</p></li>
<li><p>Heap use analysis: show all functions that are allocating or freeing memory while the trace is running.</p></li>
</ul>
<section id="how-to-diagnose-memory-leaks">
<h3>How to Diagnose Memory Leaks<a class="headerlink" href="#how-to-diagnose-memory-leaks" title="Permalink to this heading"></a></h3>
<p>If you suspect a memory leak, the first step is to figure out which part of the program is leaking memory. Use the <a class="reference internal" href="mem_alloc.html#_CPPv423heap_caps_get_free_size8uint32_t" title="heap_caps_get_free_size"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_get_free_size()</span></code></a> or related functions in <a class="reference internal" href="#heap-information"><span class="std std-ref">heap information</span></a> to track memory use over the life of the application. Try to narrow the leak down to a single function or sequence of functions where free memory always decreases and never recovers.</p>
</section>
<section id="standalone-mode">
<h3>Standalone Mode<a class="headerlink" href="#standalone-mode" title="Permalink to this heading"></a></h3>
<p>Once you have identified the code which you think is leaking:</p>
<ul class="simple">
<li><p>Enable the <a class="reference internal" href="../kconfig-reference.html#config-heap-tracing-dest"><span class="std std-ref">CONFIG_HEAP_TRACING_DEST</span></a> option.</p></li>
<li><p>Call the function <a class="reference internal" href="#_CPPv426heap_trace_init_standaloneP19heap_trace_record_t6size_t" title="heap_trace_init_standalone"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_trace_init_standalone()</span></code></a> early in the program, to register a buffer that can be used to record the memory trace.</p></li>
<li><p>Call the function <a class="reference internal" href="#_CPPv416heap_trace_start17heap_trace_mode_t" title="heap_trace_start"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_trace_start()</span></code></a> to begin recording all mallocs or frees in the system. Call this immediately before the piece of code which you suspect is leaking memory.</p></li>
<li><p>Call the function <a class="reference internal" href="#_CPPv415heap_trace_stopv" title="heap_trace_stop"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_trace_stop()</span></code></a> to stop the trace once the suspect piece of code has finished executing. This state will stop the tracing of both allocations and frees.</p></li>
<li><p>Call the function <a class="reference internal" href="#_CPPv422heap_trace_alloc_pausev" title="heap_trace_alloc_pause"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_trace_alloc_pause()</span></code></a> to pause the tracing of new allocations while continuing to trace the frees. Call this immediately after the piece of code which you suspect is leaking memory to prevent any new allocations to be recorded.</p></li>
<li><p>Call the function <a class="reference internal" href="#_CPPv415heap_trace_dumpv" title="heap_trace_dump"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_trace_dump()</span></code></a> to dump the results of the heap trace.</p></li>
</ul>
<p>The following code snippet demonstrates how application code would typically initialize, start, and stop heap tracing:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;esp_heap_trace.h&quot;</span>

<span class="cp">#define NUM_RECORDS 100</span>
<span class="k">static</span><span class="w"> </span><span class="n">heap_trace_record_t</span><span class="w"> </span><span class="n">trace_record</span><span class="p">[</span><span class="n">NUM_RECORDS</span><span class="p">];</span><span class="w"> </span><span class="c1">// This buffer must be in internal RAM</span>

<span class="p">...</span>

<span class="kt">void</span><span class="w"> </span><span class="n">app_main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">    </span><span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="w"> </span><span class="n">heap_trace_init_standalone</span><span class="p">(</span><span class="n">trace_record</span><span class="p">,</span><span class="w"> </span><span class="n">NUM_RECORDS</span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="n">some_function</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="w"> </span><span class="n">heap_trace_start</span><span class="p">(</span><span class="n">HEAP_TRACE_LEAKS</span><span class="p">)</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="n">do_something_you_suspect_is_leaking</span><span class="p">();</span>

<span class="w">    </span><span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="w"> </span><span class="n">heap_trace_stop</span><span class="p">()</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="n">heap_trace_dump</span><span class="p">();</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The output from the heap trace has a similar format to the following example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>====== Heap Trace: 8 records (8 capacity) ======
    6 bytes (@ 0x3fc9f620, Internal) allocated CPU 0 ccount 0x1a31ac84 caller 0x40376321:0x40376379
0x40376321: heap_caps_malloc at /path/to/idf/examples/components/heap/heap_caps.c:84
0x40376379: heap_caps_malloc_default at /path/to/idf/examples/components/heap/heap_caps.c:110

freed by 0x403839e4:0x42008096
0x403839e4: free at /path/to/idf/examples/components/newlib/heap.c:40
0x42008096: test_func_74 at /path/to/idf/examples/components/heap/test_apps/heap_tests/main/test_heap_trace.c:104 (discriminator 3)

    9 bytes (@ 0x3fc9f630, Internal) allocated CPU 0 ccount 0x1a31b618 caller 0x40376321:0x40376379
0x40376321: heap_caps_malloc at /path/to/idf/examples/components/heap/heap_caps.c:84
0x40376379: heap_caps_malloc_default at /path/to/idf/examples/components/heap/heap_caps.c:110

freed by 0x403839e4:0x42008096
0x403839e4: free at /path/to/idf/examples/components/newlib/heap.c:40
0x42008096: test_func_74 at /path/to/idf/examples/components/heap/test_apps/heap_tests/main/test_heap_trace.c:104 (discriminator 3)

    12 bytes (@ 0x3fc9f640, Internal) allocated CPU 0 ccount 0x1a31bfac caller 0x40376321:0x40376379
0x40376321: heap_caps_malloc at /path/to/idf/examples/components/heap/heap_caps.c:84
0x40376379: heap_caps_malloc_default at /path/to/idf/examples/components/heap/heap_caps.c:110

freed by 0x403839e4:0x42008096
0x403839e4: free at /path/to/idf/examples/components/newlib/heap.c:40
0x42008096: test_func_74 at /path/to/idf/examples/components/heap/test_apps/heap_tests/main/test_heap_trace.c:104 (discriminator 3)

    15 bytes (@ 0x3fc9f650, Internal) allocated CPU 0 ccount 0x1a31c940 caller 0x40376321:0x40376379
0x40376321: heap_caps_malloc at /path/to/idf/examples/components/heap/heap_caps.c:84
0x40376379: heap_caps_malloc_default at /path/to/idf/examples/components/heap/heap_caps.c:110

freed by 0x403839e4:0x42008096
0x403839e4: free at /path/to/idf/examples/components/newlib/heap.c:40
0x42008096: test_func_74 at /path/to/idf/examples/components/heap/test_apps/heap_tests/main/test_heap_trace.c:104 (discriminator 3)

    18 bytes (@ 0x3fc9f664, Internal) allocated CPU 0 ccount 0x1a31d2d4 caller 0x40376321:0x40376379
0x40376321: heap_caps_malloc at /path/to/idf/examples/components/heap/heap_caps.c:84
0x40376379: heap_caps_malloc_default at /path/to/idf/examples/components/heap/heap_caps.c:110

freed by 0x403839e4:0x42008096
0x403839e4: free at /path/to/idf/examples/components/newlib/heap.c:40
0x42008096: test_func_74 at /path/to/idf/examples/components/heap/test_apps/heap_tests/main/test_heap_trace.c:104 (discriminator 3)

    21 bytes (@ 0x3fc9f67c, Internal) allocated CPU 0 ccount 0x1a31dc68 caller 0x40376321:0x40376379
0x40376321: heap_caps_malloc at /path/to/idf/examples/components/heap/heap_caps.c:84
0x40376379: heap_caps_malloc_default at /path/to/idf/examples/components/heap/heap_caps.c:110

freed by 0x403839e4:0x42008096
0x403839e4: free at /path/to/idf/examples/components/newlib/heap.c:40
0x42008096: test_func_74 at /path/to/idf/examples/components/heap/test_apps/heap_tests/main/test_heap_trace.c:104 (discriminator 3)

    24 bytes (@ 0x3fc9f698, Internal) allocated CPU 0 ccount 0x1a31e600 caller 0x40376321:0x40376379
0x40376321: heap_caps_malloc at /path/to/idf/examples/components/heap/heap_caps.c:84
0x40376379: heap_caps_malloc_default at /path/to/idf/examples/components/heap/heap_caps.c:110

freed by 0x403839e4:0x42008096
0x403839e4: free at /path/to/idf/examples/components/newlib/heap.c:40
0x42008096: test_func_74 at /path/to/idf/examples/components/heap/test_apps/heap_tests/main/test_heap_trace.c:104 (discriminator 3)

    6 bytes (@ 0x3fc9f6b4, Internal) allocated CPU 0 ccount 0x1a320698 caller 0x40376321:0x40376379
0x40376321: heap_caps_malloc at /path/to/idf/examples/components/heap/heap_caps.c:84
0x40376379: heap_caps_malloc_default at /path/to/idf/examples/components/heap/heap_caps.c:110

====== Heap Trace Summary ======
Mode: Heap Trace All
6 bytes alive in trace (1/8 allocations)
records: 8 (8 capacity, 8 high water mark)
total allocations: 9
total frees: 8
================================
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The above example output uses <a class="reference internal" href="../../api-guides/tools/idf-monitor.html"><span class="doc">IDF Monitor</span></a> to automatically decode PC addresses to their source files and line numbers.</p>
<p><code class="docutils literal notranslate"><span class="pre">(NB:</span> <span class="pre">Internal</span> <span class="pre">Buffer</span> <span class="pre">has</span> <span class="pre">overflowed,</span> <span class="pre">so</span> <span class="pre">trace</span> <span class="pre">data</span> <span class="pre">is</span> <span class="pre">incomplete.)</span></code> will be logged if the list of records overflow. If you see this log, consider either shortening the tracing period or increasing the number of records in the trace buffer.</p>
<p><code class="docutils literal notranslate"><span class="pre">(NB:</span> <span class="pre">New</span> <span class="pre">entries</span> <span class="pre">were</span> <span class="pre">traced</span> <span class="pre">while</span> <span class="pre">dumping,</span> <span class="pre">so</span> <span class="pre">trace</span> <span class="pre">dump</span> <span class="pre">may</span> <span class="pre">have</span> <span class="pre">duplicate</span> <span class="pre">entries.)</span></code> will be logged in the summary if new entries are traced while calling <a class="reference internal" href="#_CPPv415heap_trace_dumpv" title="heap_trace_dump"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_trace_dump()</span></code></a> or <a class="reference internal" href="#_CPPv420heap_trace_dump_capsK8uint32_t" title="heap_trace_dump_caps"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_trace_dump_caps()</span></code></a>.</p>
</div>
<p>In <code class="docutils literal notranslate"><span class="pre">HEAP_TRACE_LEAKS</span></code> or <code class="docutils literal notranslate"><span class="pre">HEAP_TRACE_ALL</span></code> mode, for each traced memory allocation that has not already been freed, a line is printed with:</p>
<p><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">XX</span> <span class="pre">bytes</span></code> is the number of bytes allocated.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&#64;</span> <span class="pre">0x...</span></code> is the heap address returned from <a class="reference internal" href="mem_alloc.html#_CPPv416heap_caps_malloc6size_t8uint32_t" title="heap_caps_malloc"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_malloc()</span></code></a> or <a class="reference internal" href="mem_alloc.html#_CPPv416heap_caps_calloc6size_t6size_t8uint32_t" title="heap_caps_calloc"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_calloc()</span></code></a> .</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Internal</span></code> or <code class="docutils literal notranslate"><span class="pre">PSRAM</span></code> is the general location of the allocated memory.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CPU</span> <span class="pre">x</span></code> is the CPU (0 or 1) running when the allocation was made.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ccount</span> <span class="pre">0x...</span></code> is the CCOUNT (CPU cycle count) register value the allocation was made. The value is different for CPU 0 vs CPU 1.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">caller</span> <span class="pre">0x...</span></code> gives the call stack of the call to <a class="reference internal" href="mem_alloc.html#_CPPv416heap_caps_malloc6size_t8uint32_t" title="heap_caps_malloc"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_malloc()</span></code></a>, as a list of PC addresses. These can be decoded to source files and line numbers, as shown above.</p></li>
</ul>
</p>
<p>In <code class="docutils literal notranslate"><span class="pre">HEAP_TRACE_LEAKS</span></code> mode, when memory is freed, the associated record is dropped.</p>
<p>In <code class="docutils literal notranslate"><span class="pre">HEAP_TRACE_ALL</span></code>:</p>
<p><ul class="simple">
<li><p>when memory is freed, the associated record field <code class="docutils literal notranslate"><span class="pre">freed</span> <span class="pre">by</span></code> is filled with the call stack of the call to <a class="reference internal" href="mem_alloc.html#_CPPv414heap_caps_freePv" title="heap_caps_free"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_free()</span></code></a>, as a list of PC addresses. These can be decoded to source files and line numbers, as shown above.</p></li>
<li><p>After the maximum number of records is reached, old records are dropped and replaced with new records.</p></li>
</ul>
</p>
<p>The depth of the call stack recorded for each trace entry can be configured in the project configuration menu, under <code class="docutils literal notranslate"><span class="pre">Heap</span> <span class="pre">Memory</span> <span class="pre">Debugging</span></code> &gt; <code class="docutils literal notranslate"><span class="pre">Enable</span> <span class="pre">heap</span> <span class="pre">tracing</span></code> &gt; <a class="reference internal" href="../kconfig-reference.html#config-heap-tracing-stack-depth"><span class="std std-ref">CONFIG_HEAP_TRACING_STACK_DEPTH</span></a>. Up to 32 stack frames can be recorded for each allocation (the default is 2). Each additional stack frame increases the memory usage of each <code class="docutils literal notranslate"><span class="pre">heap_trace_record_t</span></code> record by eight bytes.</p>
<p>Finally, the total number of the 'leaked' bytes (bytes allocated but not freed while the trace is running) is printed together with the total number of allocations it represents.</p>
<section id="using-hashmap-for-increased-performance">
<h4>Using hashmap for increased performance<a class="headerlink" href="#using-hashmap-for-increased-performance" title="Permalink to this heading"></a></h4>
<p>By default, the heap tracing uses a statically allocated doubly-linked list to store the trace records. This has the disadvantage of causing runtime performance issues as the list gets fuller since the more items are in the list, the more time consuming it is to find a given item. This problem makes the use of the doubly linked list particularly inefficient if the user wishes to store a very large amount of records (to the point where the feature is simply no longer usable as the time it takes to retrieve an item in the list prevents the user application from executing properly).</p>
<p>For this reason, the option to use a hashmap mechanism to store records is available by enabling <code class="docutils literal notranslate"><span class="pre">Component</span> <span class="pre">config</span></code> &gt; <code class="docutils literal notranslate"><span class="pre">Heap</span> <span class="pre">Memory</span> <span class="pre">Debugging</span></code> &gt; <a class="reference internal" href="../kconfig-reference.html#config-heap-trace-hash-map"><span class="std std-ref">CONFIG_HEAP_TRACE_HASH_MAP</span></a> in the project configuration menu, allowing users to track significant amounts of records without suffering from drastic performance loss.</p>
<p>Each hashmap entry is a singly linked list of records sharing the same hash ID.</p>
<p>Each record hash ID is calculated based on the pointer to the memory they track. The hash function used is based on the Fowler-Noll-Vo hash function modified to ensure an even spread of all records in the range [0, hashmap size[ where hashmap size can be defined by setting <code class="docutils literal notranslate"><span class="pre">Component</span> <span class="pre">config</span></code> &gt; <code class="docutils literal notranslate"><span class="pre">Heap</span> <span class="pre">Memory</span> <span class="pre">Debugging</span></code> &gt; <a class="reference internal" href="../kconfig-reference.html#config-heap-trace-hash-map-size"><span class="std std-ref">CONFIG_HEAP_TRACE_HASH_MAP_SIZE</span></a> in the project configuration menu.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><ul class="simple">
<li><p>The option <a class="reference internal" href="../kconfig-reference.html#config-heap-trace-hash-map-size"><span class="std std-ref">CONFIG_HEAP_TRACE_HASH_MAP_SIZE</span></a> defines the number of entries in the hashmap. The total number of records that can be stored is still defined by the user when calling <a class="reference internal" href="#_CPPv426heap_trace_init_standaloneP19heap_trace_record_t6size_t" title="heap_trace_init_standalone"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_trace_init_standalone()</span></code></a>. If <code class="docutils literal notranslate"><span class="pre">N</span></code> is the maximum number of records and <code class="docutils literal notranslate"><span class="pre">H</span></code> the number of entries in the hashmap, Then each entry will contain at max <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">/</span> <span class="pre">H</span></code> records.</p></li>
<li><p>The hashmap complements the doubly-linked list and does not replace it. This means that the hashmap usage can create a significant memory overhead.</p></li>
<li><p>The memory used to store the hashmap is dynamically allocated (in internal memory by default) but by setting <code class="docutils literal notranslate"><span class="pre">Component</span> <span class="pre">config</span></code> &gt; <code class="docutils literal notranslate"><span class="pre">Heap</span> <span class="pre">Memory</span> <span class="pre">Debugging</span></code> &gt; <a class="reference internal" href="../kconfig-reference.html#config-heap-trace-hash-map-in-ext-ram"><span class="std std-ref">CONFIG_HEAP_TRACE_HASH_MAP_IN_EXT_RAM</span></a>, the user can force the hashmap in external memory (this option is available under the condition that <a class="reference internal" href="../kconfig-reference.html#config-spiram"><span class="std std-ref">CONFIG_SPIRAM</span></a> is enabled).</p></li>
</ul>
</p>
</div>
</section>
</section>
<section id="host-based-mode">
<h3>Host-Based Mode<a class="headerlink" href="#host-based-mode" title="Permalink to this heading"></a></h3>
<p>Once you have identified the code which you think is leaking:</p>
<ul>
<li><p>In the project configuration menu, navigate to <code class="docutils literal notranslate"><span class="pre">Component</span> <span class="pre">config</span></code> &gt; <code class="docutils literal notranslate"><span class="pre">Heap</span> <span class="pre">Memory</span> <span class="pre">Debugging</span></code> &gt; <a class="reference internal" href="../kconfig-reference.html#config-heap-tracing-dest"><span class="std std-ref">CONFIG_HEAP_TRACING_DEST</span></a> and select <code class="docutils literal notranslate"><span class="pre">Host-Based</span></code>.</p></li>
<li><p>In the project configuration menu, navigate to <code class="docutils literal notranslate"><span class="pre">Component</span> <span class="pre">config</span></code> &gt; <code class="docutils literal notranslate"><span class="pre">Application</span> <span class="pre">Level</span> <span class="pre">Tracing</span></code> &gt; <a class="reference internal" href="../kconfig-reference.html#config-apptrace-destination1"><span class="std std-ref">CONFIG_APPTRACE_DESTINATION1</span></a> and select <code class="docutils literal notranslate"><span class="pre">Trace</span> <span class="pre">memory</span></code>.</p></li>
<li><p>In the project configuration menu, navigate to <code class="docutils literal notranslate"><span class="pre">Component</span> <span class="pre">config</span></code> &gt; <code class="docutils literal notranslate"><span class="pre">Application</span> <span class="pre">Level</span> <span class="pre">Tracing</span></code> &gt; <code class="docutils literal notranslate"><span class="pre">FreeRTOS</span> <span class="pre">SystemView</span> <span class="pre">Tracing</span></code> and enable <a class="reference internal" href="../kconfig-reference.html#config-apptrace-sv-enable"><span class="std std-ref">CONFIG_APPTRACE_SV_ENABLE</span></a>.</p></li>
<li><p>Call the function <a class="reference internal" href="#_CPPv422heap_trace_init_tohostv" title="heap_trace_init_tohost"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_trace_init_tohost()</span></code></a> early in the program, to initialize the JTAG heap tracing module.</p></li>
<li><p>Call the function <a class="reference internal" href="#_CPPv416heap_trace_start17heap_trace_mode_t" title="heap_trace_start"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_trace_start()</span></code></a> to begin recording all memory allocation and free calls in the system. Call this immediately before the piece of code which you suspect is leaking memory.</p>
<p>In host-based mode, the argument to this function is ignored, and the heap tracing module behaves like <code class="docutils literal notranslate"><span class="pre">HEAP_TRACE_ALL</span></code> is passed, i.e., all allocations and deallocations are sent to the host.</p>
</li>
<li><p>Call the function <a class="reference internal" href="#_CPPv415heap_trace_stopv" title="heap_trace_stop"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_trace_stop()</span></code></a> to stop the trace once the suspect piece of code has finished executing.</p></li>
</ul>
<p>The following code snippet demonstrates how application code would typically initialize, start, and stop host-based mode heap tracing:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;esp_heap_trace.h&quot;</span>

<span class="p">...</span>

<span class="kt">void</span><span class="w"> </span><span class="n">app_main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">    </span><span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="w"> </span><span class="n">heap_trace_init_tohost</span><span class="p">()</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="n">some_function</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="w"> </span><span class="n">heap_trace_start</span><span class="p">(</span><span class="n">HEAP_TRACE_LEAKS</span><span class="p">)</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="n">do_something_you_suspect_is_leaking</span><span class="p">();</span>

<span class="w">    </span><span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="w"> </span><span class="n">heap_trace_stop</span><span class="p">()</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To gather and analyze heap trace, do the following on the host:</p>
<ol class="arabic simple">
<li><p>Build the program and download it to the target as described in <a class="reference internal" href="../../get-started/linux-macos-setup.html#get-started-build"><span class="std std-ref">Step 5. First Steps on ESP-IDF</span></a>.</p></li>
<li><p>Run OpenOCD (see <a class="reference internal" href="../../api-guides/jtag-debugging/index.html"><span class="doc">JTAG Debugging</span></a>).</p></li>
</ol>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In order to use this feature, you need OpenOCD version <code class="docutils literal notranslate"><span class="pre">v0.10.0-esp32-20181105</span></code> or later.</p>
</div>
<ol class="arabic simple" start="3">
<li><p>You can use GDB to start and/or stop tracing automatically. To do this you need to prepare a special <code class="docutils literal notranslate"><span class="pre">gdbinit</span></code> file:</p></li>
</ol>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">target</span><span class="w"> </span><span class="n">remote</span><span class="w"> </span><span class="o">:</span><span class="mi">3333</span>

<span class="n">mon</span><span class="w"> </span><span class="n">reset</span><span class="w"> </span><span class="n">halt</span>
<span class="n">maintenance</span><span class="w"> </span><span class="n">flush</span><span class="w"> </span><span class="k">register</span><span class="o">-</span><span class="n">cache</span>

<span class="n">tb</span><span class="w"> </span><span class="n">heap_trace_start</span>
<span class="n">commands</span>
<span class="n">mon</span><span class="w"> </span><span class="n">esp</span><span class="w"> </span><span class="n">sysview</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="n">file</span><span class="o">:</span><span class="c1">///tmp/heap.svdat</span>
<span class="n">c</span>
<span class="n">end</span>

<span class="n">tb</span><span class="w"> </span><span class="n">heap_trace_stop</span>
<span class="n">commands</span>
<span class="n">mon</span><span class="w"> </span><span class="n">esp</span><span class="w"> </span><span class="n">sysview</span><span class="w"> </span><span class="n">stop</span>
<span class="n">end</span>

<span class="n">c</span>
</pre></div>
</div>
<p>Using this file GDB can connect to the target, reset it, and start tracing when the program hits breakpoint at <a class="reference internal" href="#_CPPv416heap_trace_start17heap_trace_mode_t" title="heap_trace_start"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_trace_start()</span></code></a>. Tracing will be stopped when the program hits breakpoint at <a class="reference internal" href="#_CPPv415heap_trace_stopv" title="heap_trace_stop"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_trace_stop()</span></code></a>. Traced data will be saved to <code class="docutils literal notranslate"><span class="pre">/tmp/heap_log.svdat</span></code>.</p>
<ol class="arabic simple" start="4">
<li><p>Run GDB using <code class="docutils literal notranslate"><span class="pre">xtensa-esp32-elf-gdb</span> <span class="pre">-x</span> <span class="pre">gdbinit</span> <span class="pre">&lt;/path/to/program/elf&gt;</span></code>.</p></li>
<li><p>Quit GDB when the program stops at <a class="reference internal" href="#_CPPv415heap_trace_stopv" title="heap_trace_stop"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_trace_stop()</span></code></a>. Traced data are saved in <code class="docutils literal notranslate"><span class="pre">/tmp/heap.svdat</span></code>.</p></li>
<li><p>Run processing script <code class="docutils literal notranslate"><span class="pre">$IDF_PATH/tools/esp_app_trace/sysviewtrace_proc.py</span> <span class="pre">-p</span> <span class="pre">-b</span> <span class="pre">&lt;/path/to/program/elf&gt;</span> <span class="pre">/tmp/heap_log.svdat</span></code>.</p></li>
</ol>
<p>The output from the heap trace has a similar format to the following example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Parse trace from &#39;/tmp/heap.svdat&#39;...
Stop parsing trace. (Timeout 0.000000 sec while reading 1 bytes!)
Process events from &#39;[&#39;/tmp/heap.svdat&#39;]&#39;...
[0.002244575] HEAP: Allocated 1 bytes @ 0x3ffaffd8 from task &quot;alloc&quot; on core 0 by:
/home/user/projects/esp/esp-idf/examples/system/sysview_tracing_heap_log/main/sysview_heap_log.c:47
/home/user/projects/esp/esp-idf/components/freertos/port.c:355 (discriminator 1)

[0.002258425] HEAP: Allocated 2 bytes @ 0x3ffaffe0 from task &quot;alloc&quot; on core 0 by:
/home/user/projects/esp/esp-idf/examples/system/sysview_tracing_heap_log/main/sysview_heap_log.c:48
/home/user/projects/esp/esp-idf/components/freertos/port.c:355 (discriminator 1)

[0.002563725] HEAP: Freed bytes @ 0x3ffaffe0 from task &quot;free&quot; on core 0 by:
/home/user/projects/esp/esp-idf/examples/system/sysview_tracing_heap_log/main/sysview_heap_log.c:31 (discriminator 9)
/home/user/projects/esp/esp-idf/components/freertos/port.c:355 (discriminator 1)

[0.002782950] HEAP: Freed bytes @ 0x3ffb40b8 from task &quot;main&quot; on core 0 by:
/home/user/projects/esp/esp-idf/components/freertos/tasks.c:4590
/home/user/projects/esp/esp-idf/components/freertos/tasks.c:4590

[0.002798700] HEAP: Freed bytes @ 0x3ffb50bc from task &quot;main&quot; on core 0 by:
/home/user/projects/esp/esp-idf/components/freertos/tasks.c:4590
/home/user/projects/esp/esp-idf/components/freertos/tasks.c:4590

[0.102436025] HEAP: Allocated 2 bytes @ 0x3ffaffe0 from task &quot;alloc&quot; on core 0 by:
/home/user/projects/esp/esp-idf/examples/system/sysview_tracing_heap_log/main/sysview_heap_log.c:47
/home/user/projects/esp/esp-idf/components/freertos/port.c:355 (discriminator 1)

[0.102449800] HEAP: Allocated 4 bytes @ 0x3ffaffe8 from task &quot;alloc&quot; on core 0 by:
/home/user/projects/esp/esp-idf/examples/system/sysview_tracing_heap_log/main/sysview_heap_log.c:48
/home/user/projects/esp/esp-idf/components/freertos/port.c:355 (discriminator 1)

[0.102666150] HEAP: Freed bytes @ 0x3ffaffe8 from task &quot;free&quot; on core 0 by:
/home/user/projects/esp/esp-idf/examples/system/sysview_tracing_heap_log/main/sysview_heap_log.c:31 (discriminator 9)
/home/user/projects/esp/esp-idf/components/freertos/port.c:355 (discriminator 1)

[0.202436200] HEAP: Allocated 3 bytes @ 0x3ffaffe8 from task &quot;alloc&quot; on core 0 by:
/home/user/projects/esp/esp-idf/examples/system/sysview_tracing_heap_log/main/sysview_heap_log.c:47
/home/user/projects/esp/esp-idf/components/freertos/port.c:355 (discriminator 1)

[0.202451725] HEAP: Allocated 6 bytes @ 0x3ffafff0 from task &quot;alloc&quot; on core 0 by:
/home/user/projects/esp/esp-idf/examples/system/sysview_tracing_heap_log/main/sysview_heap_log.c:48
/home/user/projects/esp/esp-idf/components/freertos/port.c:355 (discriminator 1)

[0.202667075] HEAP: Freed bytes @ 0x3ffafff0 from task &quot;free&quot; on core 0 by:
/home/user/projects/esp/esp-idf/examples/system/sysview_tracing_heap_log/main/sysview_heap_log.c:31 (discriminator 9)
/home/user/projects/esp/esp-idf/components/freertos/port.c:355 (discriminator 1)

[0.302436000] HEAP: Allocated 4 bytes @ 0x3ffafff0 from task &quot;alloc&quot; on core 0 by:
/home/user/projects/esp/esp-idf/examples/system/sysview_tracing_heap_log/main/sysview_heap_log.c:47
/home/user/projects/esp/esp-idf/components/freertos/port.c:355 (discriminator 1)

[0.302451475] HEAP: Allocated 8 bytes @ 0x3ffb40b8 from task &quot;alloc&quot; on core 0 by:
/home/user/projects/esp/esp-idf/examples/system/sysview_tracing_heap_log/main/sysview_heap_log.c:48
/home/user/projects/esp/esp-idf/components/freertos/port.c:355 (discriminator 1)

[0.302667500] HEAP: Freed bytes @ 0x3ffb40b8 from task &quot;free&quot; on core 0 by:
/home/user/projects/esp/esp-idf/examples/system/sysview_tracing_heap_log/main/sysview_heap_log.c:31 (discriminator 9)
/home/user/projects/esp/esp-idf/components/freertos/port.c:355 (discriminator 1)

Processing completed.

Processed 1019 events

=============== HEAP TRACE REPORT ===============

Processed 14 heap events.

[0.002244575] HEAP: Allocated 1 bytes @ 0x3ffaffd8 from task &quot;alloc&quot; on core 0 by:
/home/user/projects/esp/esp-idf/examples/system/sysview_tracing_heap_log/main/sysview_heap_log.c:47
/home/user/projects/esp/esp-idf/components/freertos/port.c:355 (discriminator 1)

[0.102436025] HEAP: Allocated 2 bytes @ 0x3ffaffe0 from task &quot;alloc&quot; on core 0 by:
/home/user/projects/esp/esp-idf/examples/system/sysview_tracing_heap_log/main/sysview_heap_log.c:47
/home/user/projects/esp/esp-idf/components/freertos/port.c:355 (discriminator 1)

[0.202436200] HEAP: Allocated 3 bytes @ 0x3ffaffe8 from task &quot;alloc&quot; on core 0 by:
/home/user/projects/esp/esp-idf/examples/system/sysview_tracing_heap_log/main/sysview_heap_log.c:47
/home/user/projects/esp/esp-idf/components/freertos/port.c:355 (discriminator 1)

[0.302436000] HEAP: Allocated 4 bytes @ 0x3ffafff0 from task &quot;alloc&quot; on core 0 by:
/home/user/projects/esp/esp-idf/examples/system/sysview_tracing_heap_log/main/sysview_heap_log.c:47
/home/user/projects/esp/esp-idf/components/freertos/port.c:355 (discriminator 1)

Found 10 leaked bytes in 4 blocks.
</pre></div>
</div>
</section>
<section id="heap-tracing-to-find-heap-corruption">
<h3>Heap Tracing To Find Heap Corruption<a class="headerlink" href="#heap-tracing-to-find-heap-corruption" title="Permalink to this heading"></a></h3>
<p>Heap tracing can also be used to help track down heap corruption. When a region in the heap is corrupted, it may be from some other part of the program that allocated memory at a nearby address.</p>
<p>If you have an approximate idea of when the corruption occurred, enabling heap tracing in <code class="docutils literal notranslate"><span class="pre">HEAP_TRACE_ALL</span></code> mode allows you to record all the memory allocation functions used and the corresponding allocation addresses.</p>
<p>Using heap tracing in this way is very similar to memory leak detection as described above. For memories that are allocated and not freed, the output is the same. However, records will also be shown for memory that has been freed.</p>
</section>
<section id="performance-impact">
<h3>Performance Impact<a class="headerlink" href="#performance-impact" title="Permalink to this heading"></a></h3>
<p>Enabling heap tracing in menuconfig increases the code size of your program, and has a very small negative impact on the performance of heap allocation or free operations even when heap tracing is not running.</p>
<p>When heap tracing is running, heap allocation or free operations are substantially slower than when heap tracing is stopped. Increasing the depth of stack frames recorded for each allocation (see above) also increases this performance impact.</p>
<p>To mitigate the performance loss when the heap tracing is enabled and active, enable <a class="reference internal" href="../kconfig-reference.html#config-heap-trace-hash-map"><span class="std std-ref">CONFIG_HEAP_TRACE_HASH_MAP</span></a>. With this configuration enabled, a hash map mechanism will be used to handle the heap trace records, thus considerably decreasing the heap allocation or free execution time. The size of the hash map can be modified by setting the value of <a class="reference internal" href="../kconfig-reference.html#config-heap-trace-hash-map-size"><span class="std std-ref">CONFIG_HEAP_TRACE_HASH_MAP_SIZE</span></a>.</p>
<p>By default, the hash map is placed into internal RAM. It can also be placed into external RAM if <a class="reference internal" href="../kconfig-reference.html#config-heap-trace-hash-map-in-ext-ram"><span class="std std-ref">CONFIG_HEAP_TRACE_HASH_MAP_IN_EXT_RAM</span></a> is enabled. In order to enable this configuration, make sure to enable <a class="reference internal" href="../kconfig-reference.html#config-spiram"><span class="std std-ref">CONFIG_SPIRAM</span></a> and <a class="reference internal" href="../kconfig-reference.html#config-spiram-allow-bss-seg-external-memory"><span class="std std-ref">CONFIG_SPIRAM_ALLOW_BSS_SEG_EXTERNAL_MEMORY</span></a>.</p>
</section>
<section id="false-positive-memory-leaks">
<h3>False-Positive Memory Leaks<a class="headerlink" href="#false-positive-memory-leaks" title="Permalink to this heading"></a></h3>
<p>Not everything printed by <a class="reference internal" href="#_CPPv415heap_trace_dumpv" title="heap_trace_dump"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_trace_dump()</span></code></a> is necessarily a memory leak. The following cases may also be printed:</p>
<ul class="simple">
<li><p>Any memory that is allocated after <a class="reference internal" href="#_CPPv416heap_trace_start17heap_trace_mode_t" title="heap_trace_start"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_trace_start()</span></code></a> but freed after <a class="reference internal" href="#_CPPv415heap_trace_stopv" title="heap_trace_stop"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_trace_stop()</span></code></a> appears in the leaked dump.</p></li>
<li><p>Allocations may be made by other tasks in the system. Depending on the timing of these tasks, it is quite possible that this memory is freed after <a class="reference internal" href="#_CPPv415heap_trace_stopv" title="heap_trace_stop"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_trace_stop()</span></code></a> is called.</p></li>
<li><p>The first time a task uses stdio - e.g., when it calls <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_printf()</span></code> - a lock, i.e., RTOS mutex semaphore, is allocated by the libc. This allocation lasts until the task is deleted.</p></li>
<li><p>Certain uses of <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_printf()</span></code>, such as printing floating point numbers and allocating some memory from the heap on demand. These allocations last until the task is deleted.</p></li>
<li><p>The Bluetooth, Wi-Fi, and TCP/IP libraries allocate heap memory buffers to handle incoming or outgoing data. These memory buffers are usually short-lived, but some may be shown in the heap leak trace if the data has been received or transmitted by the lower levels of the network during the heap tracing.</p></li>
<li><p>TCP connections retain some memory even after they are closed due to the <code class="docutils literal notranslate"><span class="pre">TIME_WAIT</span></code> state. Once the <code class="docutils literal notranslate"><span class="pre">TIME_WAIT</span></code> period is completed, this memory will be freed.</p></li>
</ul>
<p>One way to differentiate between &quot;real&quot; and &quot;false positive&quot; memory leaks is to call the suspect code multiple times while tracing is running, and look for patterns (multiple matching allocations) in the heap trace output.</p>
</section>
</section>
<section id="application-examples">
<h2>Application Examples<a class="headerlink" href="#application-examples" title="Permalink to this heading"></a></h2>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/tree/758939ca/examples/system/heap_task_tracking/basic">system/heap_task_tracking/basic</a> demonstrates the use of the overview feature of the heap task tracking, dumping per-task summary statistics on heap memory usage.</p></li>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/tree/758939ca/examples/system/heap_task_tracking/advanced">system/heap_task_tracking/advanced</a> demonstrates the use of the statistics getter functions of the heap task tracking, accessing per-task complete statistic on the heap memory usage.</p></li>
</ul>
</section>
<section id="api-referenceheap-task-tracking">
<h2>API Reference–Heap Task Tracking<a class="headerlink" href="#api-referenceheap-task-tracking" title="Permalink to this heading"></a></h2>
<section id="header-file">
<h3>Header File<a class="headerlink" href="#header-file" title="Permalink to this heading"></a></h3>
<ul>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/blob/758939ca/components/heap/include/esp_heap_task_info.h">components/heap/include/esp_heap_task_info.h</a></p></li>
<li><p>This header file can be included with:</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;esp_heap_task_info.h&quot;</span>
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</section>
<section id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Permalink to this heading"></a></h3>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv427heap_caps_get_per_task_infoP23heap_task_info_params_t">
<span id="_CPPv327heap_caps_get_per_task_infoP23heap_task_info_params_t"></span><span id="_CPPv227heap_caps_get_per_task_infoP23heap_task_info_params_t"></span><span id="heap_caps_get_per_task_info__heap_task_info_params_tP"></span><span class="target" id="esp__heap__task__info_8h_1a6a01c27b56738a7b294b5a3dffb9a752"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">heap_caps_get_per_task_info</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv423heap_task_info_params_t" title="heap_task_info_params_t"><span class="n"><span class="pre">heap_task_info_params_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">params</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv427heap_caps_get_per_task_infoP23heap_task_info_params_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Return per-task heap allocation totals and lists of blocks. </p>
<p>For each task that has allocated memory from the heap, return totals for allocations within regions matching one or more sets of capabilities.</p>
<p>Optionally also return an array of structs providing details about each block allocated by one or more requested tasks, or by all tasks.</p>
<p><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#structheap__task__info__params__t"><span class="std std-ref">heap_task_info_params_t</span></a>). </p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#structheap__task__block__t"><span class="std std-ref">heap_task_block_t</span></a>). </p>
</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>params</strong> -- Structure to hold all the parameters for the function (</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Number of block detail structs returned (</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv427heap_caps_get_all_task_statP21heap_all_tasks_stat_t">
<span id="_CPPv327heap_caps_get_all_task_statP21heap_all_tasks_stat_t"></span><span id="_CPPv227heap_caps_get_all_task_statP21heap_all_tasks_stat_t"></span><span id="heap_caps_get_all_task_stat__heap_all_tasks_stat_tP"></span><span class="target" id="esp__heap__task__info_8h_1aff6b48ef672ebd9a04522857f4988924"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">heap_caps_get_all_task_stat</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv421heap_all_tasks_stat_t" title="heap_all_tasks_stat_t"><span class="n"><span class="pre">heap_all_tasks_stat_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">tasks_stat</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv427heap_caps_get_all_task_statP21heap_all_tasks_stat_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Return per-task heap memory usage and associated allocation information on each heap for all tasks. </p>
<p>For each task that has allocated memory from the heap, return information of memory usage and allocation information of the task on each heap the task has used.</p>
<p><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#structheap__all__tasks__stat__t"><span class="std std-ref">heap_all_tasks_stat_t</span></a>). </p>
</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>tasks_stat</strong> -- Structure to hold the memory usage statistics of all tasks (</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>ESP_OK if the information were gathered successfully. ESP_ERR_INVALID_ARG if the user defined field in <a class="reference internal" href="#structheap__all__tasks__stat__t"><span class="std std-ref">heap_all_tasks_stat_t</span></a> are not set properly </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv430heap_caps_get_single_task_statP23heap_single_task_stat_t12TaskHandle_t">
<span id="_CPPv330heap_caps_get_single_task_statP23heap_single_task_stat_t12TaskHandle_t"></span><span id="_CPPv230heap_caps_get_single_task_statP23heap_single_task_stat_t12TaskHandle_t"></span><span id="heap_caps_get_single_task_stat__heap_single_task_stat_tP.TaskHandle_t"></span><span class="target" id="esp__heap__task__info_8h_1a683786601c636b7d8f35628bbac57d09"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">heap_caps_get_single_task_stat</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv423heap_single_task_stat_t" title="heap_single_task_stat_t"><span class="n"><span class="pre">heap_single_task_stat_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">task_stat</span></span>, <a class="reference internal" href="freertos_idf.html#_CPPv412TaskHandle_t" title="TaskHandle_t"><span class="n"><span class="pre">TaskHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">task_handle</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv430heap_caps_get_single_task_statP23heap_single_task_stat_t12TaskHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Return heap memory usage and associated allocation information on each heap for a given task. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>task_handle</strong> -- <strong>[in]</strong> handle of the task. If NULL, the function will get the current task handle and return the statistics of this task. </p></li>
<li><p><strong>task_stat</strong> -- <strong>[out]</strong> Structure to hold the memory usage statistics of the task defined by task_handle </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>ESP_OK if the information were gathered successfully. ESP_ERR_INVALID_ARG if the user defined field in <a class="reference internal" href="#structheap__single__task__stat__t"><span class="std std-ref">heap_single_task_stat_t</span></a> are not set properly </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv429heap_caps_print_all_task_statP4FILE">
<span id="_CPPv329heap_caps_print_all_task_statP4FILE"></span><span id="_CPPv229heap_caps_print_all_task_statP4FILE"></span><span id="heap_caps_print_all_task_stat__FILEP"></span><span class="target" id="esp__heap__task__info_8h_1a721f88a7b0225ce9977a69f226ae65d7"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">heap_caps_print_all_task_stat</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">FILE</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">stream</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv429heap_caps_print_all_task_statP4FILE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Print heap memory usage and associated allocation information on each heap for all created tasks since startup (running and deleted ones when CONFIG_HEAP_TRACK_DELETED_TASKS is enabled). </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is an alternative to heap_caps_get_all_task_stat if the goal is just to print information and not manipulate them.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>stream</strong> -- The stream to dump to, if NULL then stdout is used </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv438heap_caps_print_all_task_stat_overviewP4FILE">
<span id="_CPPv338heap_caps_print_all_task_stat_overviewP4FILE"></span><span id="_CPPv238heap_caps_print_all_task_stat_overviewP4FILE"></span><span id="heap_caps_print_all_task_stat_overview__FILEP"></span><span class="target" id="esp__heap__task__info_8h_1ae40518ba444d333a7cb8ef64a6f5c701"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">heap_caps_print_all_task_stat_overview</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">FILE</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">stream</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv438heap_caps_print_all_task_stat_overviewP4FILE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Print summary information of all tasks. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The information printed by this function is an array formatted log of <a class="reference internal" href="#structtask__stat__t"><span class="std std-ref">task_stat_t</span></a> content for each running task (and deleted ones if HEAP_TRACK_DELETED_TASKS is enabled)</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>stream</strong> -- The stream to dump to, if NULL then stdout is used </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv432heap_caps_print_single_task_statP4FILE12TaskHandle_t">
<span id="_CPPv332heap_caps_print_single_task_statP4FILE12TaskHandle_t"></span><span id="_CPPv232heap_caps_print_single_task_statP4FILE12TaskHandle_t"></span><span id="heap_caps_print_single_task_stat__FILEP.TaskHandle_t"></span><span class="target" id="esp__heap__task__info_8h_1a2ea46d9a378ae1d3b32c6ce37e75fd10"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">heap_caps_print_single_task_stat</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">FILE</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">stream</span></span>, <a class="reference internal" href="freertos_idf.html#_CPPv412TaskHandle_t" title="TaskHandle_t"><span class="n"><span class="pre">TaskHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">task_handle</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv432heap_caps_print_single_task_statP4FILE12TaskHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Print heap memory usage and associated allocation information on each heap for a given task. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is an alternative to heap_caps_get_single_task_stat if the goal is just to print information and not manipulate them.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>stream</strong> -- The stream to dump to, if NULL then stdout is used </p></li>
<li><p><strong>task_handle</strong> -- The task handle of the task to get memory usage and associated allocation information from. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv441heap_caps_print_single_task_stat_overviewP4FILE12TaskHandle_t">
<span id="_CPPv341heap_caps_print_single_task_stat_overviewP4FILE12TaskHandle_t"></span><span id="_CPPv241heap_caps_print_single_task_stat_overviewP4FILE12TaskHandle_t"></span><span id="heap_caps_print_single_task_stat_overview__FILEP.TaskHandle_t"></span><span class="target" id="esp__heap__task__info_8h_1a0a6fafac32c41fca229cf69915ad5fe0"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">heap_caps_print_single_task_stat_overview</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">FILE</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">stream</span></span>, <a class="reference internal" href="freertos_idf.html#_CPPv412TaskHandle_t" title="TaskHandle_t"><span class="n"><span class="pre">TaskHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">task_handle</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv441heap_caps_print_single_task_stat_overviewP4FILE12TaskHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Print summary information of a given task. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The information printed by this function is an array formatted log of <a class="reference internal" href="#structtask__stat__t"><span class="std std-ref">task_stat_t</span></a> content for the given task. This function will not print the task summary information if the given task is deleted and HEAP_TRACK_DELETED_TASKS is disabled.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>stream</strong> -- The stream to dump to, if NULL then stdout is used </p></li>
<li><p><strong>task_handle</strong> -- The task handle of the task to get memory usage and associated allocation information from. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv439heap_caps_alloc_single_task_stat_arraysP23heap_single_task_stat_t12TaskHandle_t">
<span id="_CPPv339heap_caps_alloc_single_task_stat_arraysP23heap_single_task_stat_t12TaskHandle_t"></span><span id="_CPPv239heap_caps_alloc_single_task_stat_arraysP23heap_single_task_stat_t12TaskHandle_t"></span><span id="heap_caps_alloc_single_task_stat_arrays__heap_single_task_stat_tP.TaskHandle_t"></span><span class="target" id="esp__heap__task__info_8h_1ace7a514d15aa835f706a4aa99049974a"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">heap_caps_alloc_single_task_stat_arrays</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv423heap_single_task_stat_t" title="heap_single_task_stat_t"><span class="n"><span class="pre">heap_single_task_stat_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">task_stat</span></span>, <a class="reference internal" href="freertos_idf.html#_CPPv412TaskHandle_t" title="TaskHandle_t"><span class="n"><span class="pre">TaskHandle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">task_handle</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv439heap_caps_alloc_single_task_stat_arraysP23heap_single_task_stat_t12TaskHandle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Allocate the memory used to store the heap and alloc statistics and fill task_stat with the pointer to those allocations and the number of heaps and allocs statistics available for the given task. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If NULL is passed as parameter for the task_handle, the information on the currently running task will be returned. This function should be called prior to heap_caps_get_single_task_stat() if the user wishes to use dynamic allocation to store statistics.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>task_handle</strong> -- The task from which to get the information. If NULL, this function will return the number of heap used by the calling task. </p></li>
<li><p><strong>task_stat</strong> -- Structure containing information filled by this function. </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>ESP_OK if the memory necessary to gather the statistics was allocated successfully. ESP_FAIL if not enough memory space is available to store all statistics. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv438heap_caps_free_single_task_stat_arraysP23heap_single_task_stat_t">
<span id="_CPPv338heap_caps_free_single_task_stat_arraysP23heap_single_task_stat_t"></span><span id="_CPPv238heap_caps_free_single_task_stat_arraysP23heap_single_task_stat_t"></span><span id="heap_caps_free_single_task_stat_arrays__heap_single_task_stat_tP"></span><span class="target" id="esp__heap__task__info_8h_1a3a7e4670f80df03c8d9fb6a6bc6cc41e"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">heap_caps_free_single_task_stat_arrays</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv423heap_single_task_stat_t" title="heap_single_task_stat_t"><span class="n"><span class="pre">heap_single_task_stat_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">task_stat</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv438heap_caps_free_single_task_stat_arraysP23heap_single_task_stat_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Free the memory allocated to store heap and alloc statistics by calling heap_caps_alloc_single_task_stat_arrays. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>task_stat</strong> -- Structure from which to free the allocated memory used to store statistics </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv436heap_caps_alloc_all_task_stat_arraysP21heap_all_tasks_stat_t">
<span id="_CPPv336heap_caps_alloc_all_task_stat_arraysP21heap_all_tasks_stat_t"></span><span id="_CPPv236heap_caps_alloc_all_task_stat_arraysP21heap_all_tasks_stat_t"></span><span id="heap_caps_alloc_all_task_stat_arrays__heap_all_tasks_stat_tP"></span><span class="target" id="esp__heap__task__info_8h_1adee25ae15025a49eac4e897693bc837a"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">heap_caps_alloc_all_task_stat_arrays</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv421heap_all_tasks_stat_t" title="heap_all_tasks_stat_t"><span class="n"><span class="pre">heap_all_tasks_stat_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">tasks_stat</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv436heap_caps_alloc_all_task_stat_arraysP21heap_all_tasks_stat_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Allocate the memory used to store the tasks, heaps and allocs statistics and fill tasks_stat with the pointer to those allocations and the number of tasks, heaps and allocs statistics available. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function should be called prior to heap_caps_get_all_task_stat() if the user wishes to use dynamic allocation to store statistics.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>tasks_stat</strong> -- Structure containing information filled by this function. </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>ESP_OK if the memory necessary to gather the statistics was allocated successfully. ESP_FAIL if not enough memory space is available to store all statistics. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv435heap_caps_free_all_task_stat_arraysP21heap_all_tasks_stat_t">
<span id="_CPPv335heap_caps_free_all_task_stat_arraysP21heap_all_tasks_stat_t"></span><span id="_CPPv235heap_caps_free_all_task_stat_arraysP21heap_all_tasks_stat_t"></span><span id="heap_caps_free_all_task_stat_arrays__heap_all_tasks_stat_tP"></span><span class="target" id="esp__heap__task__info_8h_1a8a9176487e74595df3474ea633dc084c"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">heap_caps_free_all_task_stat_arrays</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv421heap_all_tasks_stat_t" title="heap_all_tasks_stat_t"><span class="n"><span class="pre">heap_all_tasks_stat_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">tasks_stat</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv435heap_caps_free_all_task_stat_arraysP21heap_all_tasks_stat_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Free the memory allocated to store task, heap and alloc statistics by calling heap_caps_alloc_all_task_stat_arrays. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>tasks_stat</strong> -- Structure from which to free the allocated memory used to store statistics </p>
</dd>
</dl>
</dd></dl>

</section>
<section id="structures">
<h3>Structures<a class="headerlink" href="#structures" title="Permalink to this heading"></a></h3>
<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv418heap_task_totals_t">
<span id="_CPPv318heap_task_totals_t"></span><span id="_CPPv218heap_task_totals_t"></span><span id="heap_task_totals_t"></span><span class="target" id="structheap__task__totals__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">heap_task_totals_t</span></span></span><a class="headerlink" href="#_CPPv418heap_task_totals_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Structure to collect per-task heap allocation totals partitioned by selected caps. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N18heap_task_totals_t4taskE">
<span id="_CPPv3N18heap_task_totals_t4taskE"></span><span id="_CPPv2N18heap_task_totals_t4taskE"></span><span id="heap_task_totals_t::task__TaskHandle_t"></span><span class="target" id="structheap__task__totals__t_1a01d7886f9364a3ee086a16028aca3e6d"></span><a class="reference internal" href="freertos_idf.html#_CPPv412TaskHandle_t" title="TaskHandle_t"><span class="n"><span class="pre">TaskHandle_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">task</span></span></span><a class="headerlink" href="#_CPPv4N18heap_task_totals_t4taskE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Task to which these totals belong. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N18heap_task_totals_t4sizeE">
<span id="_CPPv3N18heap_task_totals_t4sizeE"></span><span id="_CPPv2N18heap_task_totals_t4sizeE"></span><span id="heap_task_totals_t::size__sA"></span><span class="target" id="structheap__task__totals__t_1a000703d4189055fb59ed4a7d07ec01a6"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">size</span></span></span><span class="p"><span class="pre">[</span></span><span class="n"><span class="pre">NUM_HEAP_TASK_CAPS</span></span><span class="p"><span class="pre">]</span></span><a class="headerlink" href="#_CPPv4N18heap_task_totals_t4sizeE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Total allocations partitioned by selected caps. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N18heap_task_totals_t5countE">
<span id="_CPPv3N18heap_task_totals_t5countE"></span><span id="_CPPv2N18heap_task_totals_t5countE"></span><span id="heap_task_totals_t::count__sA"></span><span class="target" id="structheap__task__totals__t_1aa0f05c910d89e900a2982c3e316a191d"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">count</span></span></span><span class="p"><span class="pre">[</span></span><span class="n"><span class="pre">NUM_HEAP_TASK_CAPS</span></span><span class="p"><span class="pre">]</span></span><a class="headerlink" href="#_CPPv4N18heap_task_totals_t5countE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Number of blocks partitioned by selected caps. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv417heap_task_block_t">
<span id="_CPPv317heap_task_block_t"></span><span id="_CPPv217heap_task_block_t"></span><span id="heap_task_block_t"></span><span class="target" id="structheap__task__block__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">heap_task_block_t</span></span></span><a class="headerlink" href="#_CPPv417heap_task_block_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Structure providing details about a block allocated by a task. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N17heap_task_block_t4taskE">
<span id="_CPPv3N17heap_task_block_t4taskE"></span><span id="_CPPv2N17heap_task_block_t4taskE"></span><span id="heap_task_block_t::task__TaskHandle_t"></span><span class="target" id="structheap__task__block__t_1a5b523307753b6370f264bd1ae5a92240"></span><a class="reference internal" href="freertos_idf.html#_CPPv412TaskHandle_t" title="TaskHandle_t"><span class="n"><span class="pre">TaskHandle_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">task</span></span></span><a class="headerlink" href="#_CPPv4N17heap_task_block_t4taskE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Task that allocated the block. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N17heap_task_block_t7addressE">
<span id="_CPPv3N17heap_task_block_t7addressE"></span><span id="_CPPv2N17heap_task_block_t7addressE"></span><span id="heap_task_block_t::address__voidP"></span><span class="target" id="structheap__task__block__t_1afa550dc92e977f623c59f8b36e8095d1"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">address</span></span></span><a class="headerlink" href="#_CPPv4N17heap_task_block_t7addressE" title="Permalink to this definition"></a><br /></dt>
<dd><p>User address of allocated block. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N17heap_task_block_t4sizeE">
<span id="_CPPv3N17heap_task_block_t4sizeE"></span><span id="_CPPv2N17heap_task_block_t4sizeE"></span><span id="heap_task_block_t::size__uint32_t"></span><span class="target" id="structheap__task__block__t_1a00ad00bcb347cf0e9cce0ab241bab0d6"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">size</span></span></span><a class="headerlink" href="#_CPPv4N17heap_task_block_t4sizeE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Size of the allocated block. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv423heap_task_info_params_t">
<span id="_CPPv323heap_task_info_params_t"></span><span id="_CPPv223heap_task_info_params_t"></span><span id="heap_task_info_params_t"></span><span class="target" id="structheap__task__info__params__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">heap_task_info_params_t</span></span></span><a class="headerlink" href="#_CPPv423heap_task_info_params_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Structure to provide parameters to heap_caps_get_per_task_info. </p>
<p>The 'caps' and 'mask' arrays allow partitioning the per-task heap allocation totals by selected sets of heap region capabilities so that totals for multiple regions can be accumulated in one scan. The capabilities flags for each region ANDed with mask[i] are compared to caps[i] in order; the allocations in that region are added to totals-&gt;size[i] and totals-&gt;count[i] for the first i that matches. To collect the totals without any partitioning, set mask[0] and caps[0] both to zero. The allocation totals are returned in the 'totals' array of <a class="reference internal" href="#structheap__task__totals__t"><span class="std std-ref">heap_task_totals_t</span></a> structs. To allow easily comparing the totals array between consecutive calls, that array can be left populated from one call to the next so the order of tasks is the same even if some tasks have freed their blocks or have been deleted. The number of blocks prepopulated is given by num_totals, which is updated upon return. If there are more tasks with allocations than the capacity of the totals array (given by max_totals), information for the excess tasks will be not be collected. The totals array pointer can be NULL if the totals are not desired.</p>
<p>The 'tasks' array holds a list of handles for tasks whose block details are to be returned in the 'blocks' array of <a class="reference internal" href="#structheap__task__block__t"><span class="std std-ref">heap_task_block_t</span></a> structs. If the tasks array pointer is NULL, block details for all tasks will be returned up to the capacity of the buffer array, given by max_blocks. The function return value tells the number of blocks filled into the array. The blocks array pointer can be NULL if block details are not desired, or max_blocks can be set to zero. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23heap_task_info_params_t4capsE">
<span id="_CPPv3N23heap_task_info_params_t4capsE"></span><span id="_CPPv2N23heap_task_info_params_t4capsE"></span><span id="heap_task_info_params_t::caps__int32_tA"></span><span class="target" id="structheap__task__info__params__t_1ac17ac04c09c3a9309de4ec47f9864d84"></span><span class="n"><span class="pre">int32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">caps</span></span></span><span class="p"><span class="pre">[</span></span><span class="n"><span class="pre">NUM_HEAP_TASK_CAPS</span></span><span class="p"><span class="pre">]</span></span><a class="headerlink" href="#_CPPv4N23heap_task_info_params_t4capsE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Array of caps for partitioning task totals. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23heap_task_info_params_t4maskE">
<span id="_CPPv3N23heap_task_info_params_t4maskE"></span><span id="_CPPv2N23heap_task_info_params_t4maskE"></span><span id="heap_task_info_params_t::mask__int32_tA"></span><span class="target" id="structheap__task__info__params__t_1a042ecb4cbc3d036f7b31cd450734127c"></span><span class="n"><span class="pre">int32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mask</span></span></span><span class="p"><span class="pre">[</span></span><span class="n"><span class="pre">NUM_HEAP_TASK_CAPS</span></span><span class="p"><span class="pre">]</span></span><a class="headerlink" href="#_CPPv4N23heap_task_info_params_t4maskE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Array of masks under which caps must match. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23heap_task_info_params_t5tasksE">
<span id="_CPPv3N23heap_task_info_params_t5tasksE"></span><span id="_CPPv2N23heap_task_info_params_t5tasksE"></span><span id="heap_task_info_params_t::tasks__TaskHandle_tP"></span><span class="target" id="structheap__task__info__params__t_1a740046724ea8d1d04f40e5e7fe1d7aec"></span><a class="reference internal" href="freertos_idf.html#_CPPv412TaskHandle_t" title="TaskHandle_t"><span class="n"><span class="pre">TaskHandle_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">tasks</span></span></span><a class="headerlink" href="#_CPPv4N23heap_task_info_params_t5tasksE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Array of tasks whose block info is returned. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23heap_task_info_params_t9num_tasksE">
<span id="_CPPv3N23heap_task_info_params_t9num_tasksE"></span><span id="_CPPv2N23heap_task_info_params_t9num_tasksE"></span><span id="heap_task_info_params_t::num_tasks__s"></span><span class="target" id="structheap__task__info__params__t_1ab43cec4ef0308f49db026e25491c4929"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">num_tasks</span></span></span><a class="headerlink" href="#_CPPv4N23heap_task_info_params_t9num_tasksE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Length of tasks array. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23heap_task_info_params_t6totalsE">
<span id="_CPPv3N23heap_task_info_params_t6totalsE"></span><span id="_CPPv2N23heap_task_info_params_t6totalsE"></span><span id="heap_task_info_params_t::totals__heap_task_totals_tP"></span><span class="target" id="structheap__task__info__params__t_1ab618f1b598695f0d674b000bffed1c75"></span><a class="reference internal" href="#_CPPv418heap_task_totals_t" title="heap_task_totals_t"><span class="n"><span class="pre">heap_task_totals_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">totals</span></span></span><a class="headerlink" href="#_CPPv4N23heap_task_info_params_t6totalsE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Array of structs to collect task totals. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23heap_task_info_params_t10num_totalsE">
<span id="_CPPv3N23heap_task_info_params_t10num_totalsE"></span><span id="_CPPv2N23heap_task_info_params_t10num_totalsE"></span><span id="heap_task_info_params_t::num_totals__sP"></span><span class="target" id="structheap__task__info__params__t_1a1d8c754ab735f9317177b79cf645c717"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">num_totals</span></span></span><a class="headerlink" href="#_CPPv4N23heap_task_info_params_t10num_totalsE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Number of task structs currently in array. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23heap_task_info_params_t10max_totalsE">
<span id="_CPPv3N23heap_task_info_params_t10max_totalsE"></span><span id="_CPPv2N23heap_task_info_params_t10max_totalsE"></span><span id="heap_task_info_params_t::max_totals__s"></span><span class="target" id="structheap__task__info__params__t_1ac01274a105b339aee94c047ccf87767c"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">max_totals</span></span></span><a class="headerlink" href="#_CPPv4N23heap_task_info_params_t10max_totalsE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Capacity of array of task totals structs. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23heap_task_info_params_t6blocksE">
<span id="_CPPv3N23heap_task_info_params_t6blocksE"></span><span id="_CPPv2N23heap_task_info_params_t6blocksE"></span><span id="heap_task_info_params_t::blocks__heap_task_block_tP"></span><span class="target" id="structheap__task__info__params__t_1a44a4950d7982eae34f720732af678bd6"></span><a class="reference internal" href="#_CPPv417heap_task_block_t" title="heap_task_block_t"><span class="n"><span class="pre">heap_task_block_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">blocks</span></span></span><a class="headerlink" href="#_CPPv4N23heap_task_info_params_t6blocksE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Array of task block details structs. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23heap_task_info_params_t10max_blocksE">
<span id="_CPPv3N23heap_task_info_params_t10max_blocksE"></span><span id="_CPPv2N23heap_task_info_params_t10max_blocksE"></span><span id="heap_task_info_params_t::max_blocks__s"></span><span class="target" id="structheap__task__info__params__t_1a090a4feb1c878df6addbf7a146fed3d8"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">max_blocks</span></span></span><a class="headerlink" href="#_CPPv4N23heap_task_info_params_t10max_blocksE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Capacity of array of task block info structs. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv411heap_stat_t">
<span id="_CPPv311heap_stat_t"></span><span id="_CPPv211heap_stat_t"></span><span id="heap_stat_t"></span><span class="target" id="structheap__stat__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">heap_stat_t</span></span></span><a class="headerlink" href="#_CPPv411heap_stat_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Structure providing details about memory usage of a given task on a heap. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N11heap_stat_t4nameE">
<span id="_CPPv3N11heap_stat_t4nameE"></span><span id="_CPPv2N11heap_stat_t4nameE"></span><span id="heap_stat_t::name__cCP"></span><span class="target" id="structheap__stat__t_1ad6c216b871e3e667cd516e90a9448829"></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">name</span></span></span><a class="headerlink" href="#_CPPv4N11heap_stat_t4nameE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Pointer to the name of the heap defined in soc_memory_types[]. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N11heap_stat_t4capsE">
<span id="_CPPv3N11heap_stat_t4capsE"></span><span id="_CPPv2N11heap_stat_t4capsE"></span><span id="heap_stat_t::caps__uint32_t"></span><span class="target" id="structheap__stat__t_1a07e6886b90a2b453caa5dfb8f778d471"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">caps</span></span></span><a class="headerlink" href="#_CPPv4N11heap_stat_t4capsE" title="Permalink to this definition"></a><br /></dt>
<dd><p>All caps supported by the heap (ORED) </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N11heap_stat_t4sizeE">
<span id="_CPPv3N11heap_stat_t4sizeE"></span><span id="_CPPv2N11heap_stat_t4sizeE"></span><span id="heap_stat_t::size__s"></span><span class="target" id="structheap__stat__t_1a25e811cc55953f1b019fdf037ad54067"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">size</span></span></span><a class="headerlink" href="#_CPPv4N11heap_stat_t4sizeE" title="Permalink to this definition"></a><br /></dt>
<dd><p>The available size of the heap. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N11heap_stat_t13current_usageE">
<span id="_CPPv3N11heap_stat_t13current_usageE"></span><span id="_CPPv2N11heap_stat_t13current_usageE"></span><span id="heap_stat_t::current_usage__s"></span><span class="target" id="structheap__stat__t_1a3f4de1f13094b56d64240eac8e64acd5"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">current_usage</span></span></span><a class="headerlink" href="#_CPPv4N11heap_stat_t13current_usageE" title="Permalink to this definition"></a><br /></dt>
<dd><p>The current usage of a given task on the heap. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N11heap_stat_t10peak_usageE">
<span id="_CPPv3N11heap_stat_t10peak_usageE"></span><span id="_CPPv2N11heap_stat_t10peak_usageE"></span><span id="heap_stat_t::peak_usage__s"></span><span class="target" id="structheap__stat__t_1acfb69ac3398228b34725b54f88546fa2"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">peak_usage</span></span></span><a class="headerlink" href="#_CPPv4N11heap_stat_t10peak_usageE" title="Permalink to this definition"></a><br /></dt>
<dd><p>The peak usage since startup on a given task on the heap. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N11heap_stat_t11alloc_countE">
<span id="_CPPv3N11heap_stat_t11alloc_countE"></span><span id="_CPPv2N11heap_stat_t11alloc_countE"></span><span id="heap_stat_t::alloc_count__s"></span><span class="target" id="structheap__stat__t_1abd55ef1db192f8ed089a63f3d1c22a7c"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">alloc_count</span></span></span><a class="headerlink" href="#_CPPv4N11heap_stat_t11alloc_countE" title="Permalink to this definition"></a><br /></dt>
<dd><p>The current number of allocation by a given task on the heap. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N11heap_stat_t10alloc_statE">
<span id="_CPPv3N11heap_stat_t10alloc_statE"></span><span id="_CPPv2N11heap_stat_t10alloc_statE"></span><span id="heap_stat_t::alloc_stat__heap_task_block_tP"></span><span class="target" id="structheap__stat__t_1aba54866e09663450201f2d46ff8dd965"></span><a class="reference internal" href="#_CPPv417heap_task_block_t" title="heap_task_block_t"><span class="n"><span class="pre">heap_task_block_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">alloc_stat</span></span></span><a class="headerlink" href="#_CPPv4N11heap_stat_t10alloc_statE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Pointer to an array of allocation stats for a given task on the heap. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv411task_stat_t">
<span id="_CPPv311task_stat_t"></span><span id="_CPPv211task_stat_t"></span><span id="task_stat_t"></span><span class="target" id="structtask__stat__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">task_stat_t</span></span></span><a class="headerlink" href="#_CPPv411task_stat_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Structure providing details about a task. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N11task_stat_t4nameE">
<span id="_CPPv3N11task_stat_t4nameE"></span><span id="_CPPv2N11task_stat_t4nameE"></span><span id="task_stat_t::name__cA"></span><span class="target" id="structtask__stat__t_1a8ec93155b22c8398a07e67411d7b53b8"></span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">name</span></span></span><span class="p"><span class="pre">[</span></span><span class="n"><span class="pre">configMAX_TASK_NAME_LEN</span></span><span class="p"><span class="pre">]</span></span><a class="headerlink" href="#_CPPv4N11task_stat_t4nameE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Name of the task. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N11task_stat_t6handleE">
<span id="_CPPv3N11task_stat_t6handleE"></span><span id="_CPPv2N11task_stat_t6handleE"></span><span id="task_stat_t::handle__TaskHandle_t"></span><span class="target" id="structtask__stat__t_1a80da11e135e678ce96fee9a47f3e71cf"></span><a class="reference internal" href="freertos_idf.html#_CPPv412TaskHandle_t" title="TaskHandle_t"><span class="n"><span class="pre">TaskHandle_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">handle</span></span></span><a class="headerlink" href="#_CPPv4N11task_stat_t6handleE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Pointer to the task handle. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N11task_stat_t8is_aliveE">
<span id="_CPPv3N11task_stat_t8is_aliveE"></span><span id="_CPPv2N11task_stat_t8is_aliveE"></span><span id="task_stat_t::is_alive__b"></span><span class="target" id="structtask__stat__t_1af47ca01c26b46364a5fe91a5ccdea28f"></span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">is_alive</span></span></span><a class="headerlink" href="#_CPPv4N11task_stat_t8is_aliveE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Information whether the task is alive (true) or deleted (false) </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N11task_stat_t18overall_peak_usageE">
<span id="_CPPv3N11task_stat_t18overall_peak_usageE"></span><span id="_CPPv2N11task_stat_t18overall_peak_usageE"></span><span id="task_stat_t::overall_peak_usage__s"></span><span class="target" id="structtask__stat__t_1ada7d7ef4a9b2bc2138d2ea61cfed0bfa"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">overall_peak_usage</span></span></span><a class="headerlink" href="#_CPPv4N11task_stat_t18overall_peak_usageE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Information about the memory peak usage across all heaps of a given task. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N11task_stat_t21overall_current_usageE">
<span id="_CPPv3N11task_stat_t21overall_current_usageE"></span><span id="_CPPv2N11task_stat_t21overall_current_usageE"></span><span id="task_stat_t::overall_current_usage__s"></span><span class="target" id="structtask__stat__t_1aaaa54028e5dc5206d68bfd9bb89d5c88"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">overall_current_usage</span></span></span><a class="headerlink" href="#_CPPv4N11task_stat_t21overall_current_usageE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Information about the memory current usage across all heaps of a given task. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N11task_stat_t10heap_countE">
<span id="_CPPv3N11task_stat_t10heap_countE"></span><span id="_CPPv2N11task_stat_t10heap_countE"></span><span id="task_stat_t::heap_count__s"></span><span class="target" id="structtask__stat__t_1ad57a28c50b5399ee0b74482cf60771fa"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">heap_count</span></span></span><a class="headerlink" href="#_CPPv4N11task_stat_t10heap_countE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Number of different heaps the task has used since its creation. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N11task_stat_t9heap_statE">
<span id="_CPPv3N11task_stat_t9heap_statE"></span><span id="_CPPv2N11task_stat_t9heap_statE"></span><span id="task_stat_t::heap_stat__heap_stat_tP"></span><span class="target" id="structtask__stat__t_1a8c8eae3679753f82f22cb8b92b9c8032"></span><a class="reference internal" href="#_CPPv411heap_stat_t" title="heap_stat_t"><span class="n"><span class="pre">heap_stat_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">heap_stat</span></span></span><a class="headerlink" href="#_CPPv4N11task_stat_t9heap_statE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Pointer to an array containing statistics of the heaps used by the task. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv423heap_single_task_stat_t">
<span id="_CPPv323heap_single_task_stat_t"></span><span id="_CPPv223heap_single_task_stat_t"></span><span id="heap_single_task_stat_t"></span><span class="target" id="structheap__single__task__stat__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">heap_single_task_stat_t</span></span></span><a class="headerlink" href="#_CPPv423heap_single_task_stat_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>User interface containing the statistics of a given task and the associated memory usage of the task on each heap. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23heap_single_task_stat_t4statE">
<span id="_CPPv3N23heap_single_task_stat_t4statE"></span><span id="_CPPv2N23heap_single_task_stat_t4statE"></span><span id="heap_single_task_stat_t::stat__task_stat_t"></span><span class="target" id="structheap__single__task__stat__t_1a2059f1388596e990ddd5c864a7ad08ae"></span><a class="reference internal" href="#_CPPv411task_stat_t" title="task_stat_t"><span class="n"><span class="pre">task_stat_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">stat</span></span></span><a class="headerlink" href="#_CPPv4N23heap_single_task_stat_t4statE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Statistics of the task. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23heap_single_task_stat_t10heap_countE">
<span id="_CPPv3N23heap_single_task_stat_t10heap_countE"></span><span id="_CPPv2N23heap_single_task_stat_t10heap_countE"></span><span id="heap_single_task_stat_t::heap_count__s"></span><span class="target" id="structheap__single__task__stat__t_1a4bda476cdf1c489cdce093071fdb3bc2"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">heap_count</span></span></span><a class="headerlink" href="#_CPPv4N23heap_single_task_stat_t10heap_countE" title="Permalink to this definition"></a><br /></dt>
<dd><p>size of user defined heap_stat array </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23heap_single_task_stat_t15heap_stat_startE">
<span id="_CPPv3N23heap_single_task_stat_t15heap_stat_startE"></span><span id="_CPPv2N23heap_single_task_stat_t15heap_stat_startE"></span><span id="heap_single_task_stat_t::heap_stat_start__heap_stat_tP"></span><span class="target" id="structheap__single__task__stat__t_1af519bbf3c85df719cc337576e46b3cdf"></span><a class="reference internal" href="#_CPPv411heap_stat_t" title="heap_stat_t"><span class="n"><span class="pre">heap_stat_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">heap_stat_start</span></span></span><a class="headerlink" href="#_CPPv4N23heap_single_task_stat_t15heap_stat_startE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Pointer to the start to the user defined heap_stat array. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23heap_single_task_stat_t11alloc_countE">
<span id="_CPPv3N23heap_single_task_stat_t11alloc_countE"></span><span id="_CPPv2N23heap_single_task_stat_t11alloc_countE"></span><span id="heap_single_task_stat_t::alloc_count__s"></span><span class="target" id="structheap__single__task__stat__t_1aad85e6ebb2604b025f7ecc585a7024b4"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">alloc_count</span></span></span><a class="headerlink" href="#_CPPv4N23heap_single_task_stat_t11alloc_countE" title="Permalink to this definition"></a><br /></dt>
<dd><p>size of user defined alloc_stat array </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N23heap_single_task_stat_t16alloc_stat_startE">
<span id="_CPPv3N23heap_single_task_stat_t16alloc_stat_startE"></span><span id="_CPPv2N23heap_single_task_stat_t16alloc_stat_startE"></span><span id="heap_single_task_stat_t::alloc_stat_start__heap_task_block_tP"></span><span class="target" id="structheap__single__task__stat__t_1a0b3745f2d00c9a83fe35869675565f89"></span><a class="reference internal" href="#_CPPv417heap_task_block_t" title="heap_task_block_t"><span class="n"><span class="pre">heap_task_block_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">alloc_stat_start</span></span></span><a class="headerlink" href="#_CPPv4N23heap_single_task_stat_t16alloc_stat_startE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Pointer to the start to the user defined alloc_stat array. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv421heap_all_tasks_stat_t">
<span id="_CPPv321heap_all_tasks_stat_t"></span><span id="_CPPv221heap_all_tasks_stat_t"></span><span id="heap_all_tasks_stat_t"></span><span class="target" id="structheap__all__tasks__stat__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">heap_all_tasks_stat_t</span></span></span><a class="headerlink" href="#_CPPv421heap_all_tasks_stat_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>User interface containing the statistics of all tasks and the associated memory usage of those tasks on each heap they use. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N21heap_all_tasks_stat_t10task_countE">
<span id="_CPPv3N21heap_all_tasks_stat_t10task_countE"></span><span id="_CPPv2N21heap_all_tasks_stat_t10task_countE"></span><span id="heap_all_tasks_stat_t::task_count__s"></span><span class="target" id="structheap__all__tasks__stat__t_1a34c4a1540a76aa89d58592823b3414d2"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">task_count</span></span></span><a class="headerlink" href="#_CPPv4N21heap_all_tasks_stat_t10task_countE" title="Permalink to this definition"></a><br /></dt>
<dd><p>user defined size of <a class="reference internal" href="#structheap__single__task__stat__t"><span class="std std-ref">heap_single_task_stat_t</span></a> array </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N21heap_all_tasks_stat_t8stat_arrE">
<span id="_CPPv3N21heap_all_tasks_stat_t8stat_arrE"></span><span id="_CPPv2N21heap_all_tasks_stat_t8stat_arrE"></span><span id="heap_all_tasks_stat_t::stat_arr__task_stat_tP"></span><span class="target" id="structheap__all__tasks__stat__t_1a221009ae1c6f1d410bc5f6f5145fb1a5"></span><a class="reference internal" href="#_CPPv411task_stat_t" title="task_stat_t"><span class="n"><span class="pre">task_stat_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">stat_arr</span></span></span><a class="headerlink" href="#_CPPv4N21heap_all_tasks_stat_t8stat_arrE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Pointer to the user defined array of <a class="reference internal" href="#structheap__single__task__stat__t"><span class="std std-ref">heap_single_task_stat_t</span></a>. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N21heap_all_tasks_stat_t10heap_countE">
<span id="_CPPv3N21heap_all_tasks_stat_t10heap_countE"></span><span id="_CPPv2N21heap_all_tasks_stat_t10heap_countE"></span><span id="heap_all_tasks_stat_t::heap_count__s"></span><span class="target" id="structheap__all__tasks__stat__t_1a38d84d08752a8d766a476797fb1e6aec"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">heap_count</span></span></span><a class="headerlink" href="#_CPPv4N21heap_all_tasks_stat_t10heap_countE" title="Permalink to this definition"></a><br /></dt>
<dd><p>size of user defined heap_stat array </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N21heap_all_tasks_stat_t15heap_stat_startE">
<span id="_CPPv3N21heap_all_tasks_stat_t15heap_stat_startE"></span><span id="_CPPv2N21heap_all_tasks_stat_t15heap_stat_startE"></span><span id="heap_all_tasks_stat_t::heap_stat_start__heap_stat_tP"></span><span class="target" id="structheap__all__tasks__stat__t_1ab74623acd85bc757ff830166128d1486"></span><a class="reference internal" href="#_CPPv411heap_stat_t" title="heap_stat_t"><span class="n"><span class="pre">heap_stat_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">heap_stat_start</span></span></span><a class="headerlink" href="#_CPPv4N21heap_all_tasks_stat_t15heap_stat_startE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Pointer to the start to the user defined heap_stat array. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N21heap_all_tasks_stat_t11alloc_countE">
<span id="_CPPv3N21heap_all_tasks_stat_t11alloc_countE"></span><span id="_CPPv2N21heap_all_tasks_stat_t11alloc_countE"></span><span id="heap_all_tasks_stat_t::alloc_count__s"></span><span class="target" id="structheap__all__tasks__stat__t_1a6e294c3a0ed9d41c8615a4f47673b9f5"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">alloc_count</span></span></span><a class="headerlink" href="#_CPPv4N21heap_all_tasks_stat_t11alloc_countE" title="Permalink to this definition"></a><br /></dt>
<dd><p>size of user defined alloc_stat array </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N21heap_all_tasks_stat_t16alloc_stat_startE">
<span id="_CPPv3N21heap_all_tasks_stat_t16alloc_stat_startE"></span><span id="_CPPv2N21heap_all_tasks_stat_t16alloc_stat_startE"></span><span id="heap_all_tasks_stat_t::alloc_stat_start__heap_task_block_tP"></span><span class="target" id="structheap__all__tasks__stat__t_1aa70e1386442f6b58df8e0945bb2581e6"></span><a class="reference internal" href="#_CPPv417heap_task_block_t" title="heap_task_block_t"><span class="n"><span class="pre">heap_task_block_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">alloc_stat_start</span></span></span><a class="headerlink" href="#_CPPv4N21heap_all_tasks_stat_t16alloc_stat_startE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Pointer to the start to the user defined alloc_stat array. </p>
</dd></dl>

</div>
</dd></dl>

</section>
<section id="macros">
<h3>Macros<a class="headerlink" href="#macros" title="Permalink to this heading"></a></h3>
<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.NUM_HEAP_TASK_CAPS">
<span class="target" id="esp__heap__task__info_8h_1a8ad4981706e6690f3dfad2791d9905b0"></span><span class="sig-name descname"><span class="n"><span class="pre">NUM_HEAP_TASK_CAPS</span></span></span><a class="headerlink" href="#c.NUM_HEAP_TASK_CAPS" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

</section>
</section>
<section id="api-referenceheap-tracing">
<h2>API Reference–Heap Tracing<a class="headerlink" href="#api-referenceheap-tracing" title="Permalink to this heading"></a></h2>
<section id="id4">
<h3>Header File<a class="headerlink" href="#id4" title="Permalink to this heading"></a></h3>
<ul>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/blob/758939ca/components/heap/include/esp_heap_trace.h">components/heap/include/esp_heap_trace.h</a></p></li>
<li><p>This header file can be included with:</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;esp_heap_trace.h&quot;</span>
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</section>
<section id="id5">
<h3>Functions<a class="headerlink" href="#id5" title="Permalink to this heading"></a></h3>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv426heap_trace_init_standaloneP19heap_trace_record_t6size_t">
<span id="_CPPv326heap_trace_init_standaloneP19heap_trace_record_t6size_t"></span><span id="_CPPv226heap_trace_init_standaloneP19heap_trace_record_t6size_t"></span><span id="heap_trace_init_standalone__heap_trace_record_tP.s"></span><span class="target" id="esp__heap__trace_8h_1a8884934797d03cc7114b64f1849420e2"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">heap_trace_init_standalone</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv419heap_trace_record_t" title="heap_trace_record_t"><span class="n"><span class="pre">heap_trace_record_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">record_buffer</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">num_records</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv426heap_trace_init_standaloneP19heap_trace_record_t6size_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Initialise heap tracing in standalone mode. </p>
<p>This function must be called before any other heap tracing functions.</p>
<p>To disable heap tracing and allow the buffer to be freed, stop tracing and then call heap_trace_init_standalone(NULL, 0);</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>record_buffer</strong> -- Provide a buffer to use for heap trace data. Note: External RAM is allowed, but it prevents recording allocations made from ISR's. </p></li>
<li><p><strong>num_records</strong> -- Size of the heap trace buffer, as number of record structures. </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_ERR_NOT_SUPPORTED Project was compiled without heap tracing enabled in menuconfig.</p></li>
<li><p>ESP_ERR_INVALID_STATE Heap tracing is currently in progress.</p></li>
<li><p>ESP_OK Heap tracing initialised successfully. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv422heap_trace_init_tohostv">
<span id="_CPPv322heap_trace_init_tohostv"></span><span id="_CPPv222heap_trace_init_tohostv"></span><span id="heap_trace_init_tohost__void"></span><span class="target" id="esp__heap__trace_8h_1a01c97e0002efcd2a3402a412640b02fd"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">heap_trace_init_tohost</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422heap_trace_init_tohostv" title="Permalink to this definition"></a><br /></dt>
<dd><p>Initialise heap tracing in host-based mode. </p>
<p>This function must be called before any other heap tracing functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><ul class="simple">
<li><p>ESP_ERR_INVALID_STATE Heap tracing is currently in progress.</p></li>
<li><p>ESP_OK Heap tracing initialised successfully. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv416heap_trace_start17heap_trace_mode_t">
<span id="_CPPv316heap_trace_start17heap_trace_mode_t"></span><span id="_CPPv216heap_trace_start17heap_trace_mode_t"></span><span id="heap_trace_start__heap_trace_mode_t"></span><span class="target" id="esp__heap__trace_8h_1ac324e6c910f4a2a71e0e364130c069b6"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">heap_trace_start</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv417heap_trace_mode_t" title="heap_trace_mode_t"><span class="n"><span class="pre">heap_trace_mode_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">mode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416heap_trace_start17heap_trace_mode_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Start heap tracing. All heap allocations &amp; frees will be traced, until heap_trace_stop() is called. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>heap_trace_init_standalone() must be called to provide a valid buffer, before this function is called.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calling this function while heap tracing is running will reset the heap trace state and continue tracing.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>mode</strong> -- Mode for tracing.<ul class="simple">
<li><p>HEAP_TRACE_ALL means all heap allocations and frees are traced.</p></li>
<li><p>HEAP_TRACE_LEAKS means only suspected memory leaks are traced. (When memory is freed, the record is removed from the trace buffer.) </p></li>
</ul>
</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_ERR_NOT_SUPPORTED Project was compiled without heap tracing enabled in menuconfig.</p></li>
<li><p>ESP_ERR_INVALID_STATE A non-zero-length buffer has not been set via heap_trace_init_standalone().</p></li>
<li><p>ESP_OK Tracing is started. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv415heap_trace_stopv">
<span id="_CPPv315heap_trace_stopv"></span><span id="_CPPv215heap_trace_stopv"></span><span id="heap_trace_stop__void"></span><span class="target" id="esp__heap__trace_8h_1aa2a9740da05f6833efbc39c0520681de"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">heap_trace_stop</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415heap_trace_stopv" title="Permalink to this definition"></a><br /></dt>
<dd><p>Stop heap tracing. </p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><ul class="simple">
<li><p>ESP_ERR_NOT_SUPPORTED Project was compiled without heap tracing enabled in menuconfig.</p></li>
<li><p>ESP_ERR_INVALID_STATE Heap tracing was not in progress.</p></li>
<li><p>ESP_OK Heap tracing stopped. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv422heap_trace_alloc_pausev">
<span id="_CPPv322heap_trace_alloc_pausev"></span><span id="_CPPv222heap_trace_alloc_pausev"></span><span id="heap_trace_alloc_pause__void"></span><span class="target" id="esp__heap__trace_8h_1acb0dff8e79267ab04a8d5350c36c01be"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">heap_trace_alloc_pause</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422heap_trace_alloc_pausev" title="Permalink to this definition"></a><br /></dt>
<dd><p>Pause heap tracing of allocations. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function puts the heap tracing in the state where the new allocations will no longer be traced but the free will still be. This can be used to e.g., strategically monitor a set of allocations to make sure each of them will get freed without polluting the list of records with unwanted allocations.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><ul class="simple">
<li><p>ESP_ERR_NOT_SUPPORTED Project was compiled without heap tracing enabled in menuconfig.</p></li>
<li><p>ESP_ERR_INVALID_STATE Heap tracing was not in progress.</p></li>
<li><p>ESP_OK Heap tracing paused. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417heap_trace_resumev">
<span id="_CPPv317heap_trace_resumev"></span><span id="_CPPv217heap_trace_resumev"></span><span id="heap_trace_resume__void"></span><span class="target" id="esp__heap__trace_8h_1a62cef359ef92ecb1b0760b3e1e5e1203"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">heap_trace_resume</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417heap_trace_resumev" title="Permalink to this definition"></a><br /></dt>
<dd><p>Resume heap tracing which was previously stopped. </p>
<p>Unlike heap_trace_start(), this function does not clear the buffer of any pre-existing trace records.</p>
<p>The heap trace mode is the same as when heap_trace_start() was last called (or HEAP_TRACE_ALL if heap_trace_start() was never called).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><ul class="simple">
<li><p>ESP_ERR_NOT_SUPPORTED Project was compiled without heap tracing enabled in menuconfig.</p></li>
<li><p>ESP_ERR_INVALID_STATE Heap tracing was already started.</p></li>
<li><p>ESP_OK Heap tracing resumed. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv420heap_trace_get_countv">
<span id="_CPPv320heap_trace_get_countv"></span><span id="_CPPv220heap_trace_get_countv"></span><span id="heap_trace_get_count__void"></span><span class="target" id="esp__heap__trace_8h_1a9ac798a6e570fd665d6e5c715c1a3d1b"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">heap_trace_get_count</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420heap_trace_get_countv" title="Permalink to this definition"></a><br /></dt>
<dd><p>Return number of records in the heap trace buffer. </p>
<p>It is safe to call this function while heap tracing is running. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv414heap_trace_get6size_tP19heap_trace_record_t">
<span id="_CPPv314heap_trace_get6size_tP19heap_trace_record_t"></span><span id="_CPPv214heap_trace_get6size_tP19heap_trace_record_t"></span><span id="heap_trace_get__s.heap_trace_record_tP"></span><span class="target" id="esp__heap__trace_8h_1a007b0b85daa123d2a7a7d74e6383f42c"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">heap_trace_get</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">index</span></span>, <a class="reference internal" href="#_CPPv419heap_trace_record_t" title="heap_trace_record_t"><span class="n"><span class="pre">heap_trace_record_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">record</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414heap_trace_get6size_tP19heap_trace_record_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Return a raw record from the heap trace buffer. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is safe to call this function while heap tracing is running, however in HEAP_TRACE_LEAK mode record indexing may skip entries unless heap tracing is stopped first.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>index</strong> -- Index (zero-based) of the record to return. </p></li>
<li><p><strong>record</strong> -- <strong>[out]</strong> Record where the heap trace record will be copied. </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_ERR_NOT_SUPPORTED Project was compiled without heap tracing enabled in menuconfig.</p></li>
<li><p>ESP_ERR_INVALID_STATE Heap tracing was not initialised.</p></li>
<li><p>ESP_ERR_INVALID_ARG Index is out of bounds for current heap trace record count.</p></li>
<li><p>ESP_OK Record returned successfully. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv415heap_trace_dumpv">
<span id="_CPPv315heap_trace_dumpv"></span><span id="_CPPv215heap_trace_dumpv"></span><span id="heap_trace_dump__void"></span><span class="target" id="esp__heap__trace_8h_1a9e80331ce5188a84bb60fdf0bd1ab828"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">heap_trace_dump</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415heap_trace_dumpv" title="Permalink to this definition"></a><br /></dt>
<dd><p>Dump heap trace record data to stdout. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is safe to call this function while heap tracing is running, however in HEAP_TRACE_LEAK mode the dump may skip entries unless heap tracing is stopped first. </p>
</div>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv420heap_trace_dump_capsK8uint32_t">
<span id="_CPPv320heap_trace_dump_capsK8uint32_t"></span><span id="_CPPv220heap_trace_dump_capsK8uint32_t"></span><span id="heap_trace_dump_caps__uint32_tC"></span><span class="target" id="esp__heap__trace_8h_1a34ce005489fd109724235c2a56b6ba6e"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">heap_trace_dump_caps</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">caps</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420heap_trace_dump_capsK8uint32_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Dump heap trace from the memory of the capabilities passed as parameter. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>caps</strong> -- Capability(ies) of the memory from which to dump the trace. Set MALLOC_CAP_INTERNAL to dump heap trace data from internal memory. Set MALLOC_CAP_SPIRAM to dump heap trace data from PSRAM. Set both to dump both heap trace data. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv418heap_trace_summaryP20heap_trace_summary_t">
<span id="_CPPv318heap_trace_summaryP20heap_trace_summary_t"></span><span id="_CPPv218heap_trace_summaryP20heap_trace_summary_t"></span><span id="heap_trace_summary__heap_trace_summary_tP"></span><span class="target" id="esp__heap__trace_8h_1a53cd82e24a7196120841e2742e4e8203"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">heap_trace_summary</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv420heap_trace_summary_t" title="heap_trace_summary_t"><span class="n"><span class="pre">heap_trace_summary_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">summary</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418heap_trace_summaryP20heap_trace_summary_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Get summary information about the result of a heap trace. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is safe to call this function while heap tracing is running. </p>
</div>
</dd></dl>

</section>
<section id="id6">
<h3>Structures<a class="headerlink" href="#id6" title="Permalink to this heading"></a></h3>
<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv419heap_trace_record_t">
<span id="_CPPv319heap_trace_record_t"></span><span id="_CPPv219heap_trace_record_t"></span><span id="heap_trace_record_t"></span><span class="target" id="structheap__trace__record__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">heap_trace_record_t</span></span></span><a class="headerlink" href="#_CPPv419heap_trace_record_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Trace record data type. Stores information about an allocated region of memory. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N19heap_trace_record_t6ccountE">
<span id="_CPPv3N19heap_trace_record_t6ccountE"></span><span id="_CPPv2N19heap_trace_record_t6ccountE"></span><span id="heap_trace_record_t::ccount__uint32_t"></span><span class="target" id="structheap__trace__record__t_1a3a5a11507218cbab8b0f1ec08f8f5c40"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ccount</span></span></span><a class="headerlink" href="#_CPPv4N19heap_trace_record_t6ccountE" title="Permalink to this definition"></a><br /></dt>
<dd><p>CCOUNT of the CPU when the allocation was made. LSB (bit value 1) is the CPU number (0 or 1). </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N19heap_trace_record_t7addressE">
<span id="_CPPv3N19heap_trace_record_t7addressE"></span><span id="_CPPv2N19heap_trace_record_t7addressE"></span><span id="heap_trace_record_t::address__voidP"></span><span class="target" id="structheap__trace__record__t_1a948933cb24b2aa572f45b806e82ae818"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">address</span></span></span><a class="headerlink" href="#_CPPv4N19heap_trace_record_t7addressE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Address which was allocated. If NULL, then this record is empty. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N19heap_trace_record_t4sizeE">
<span id="_CPPv3N19heap_trace_record_t4sizeE"></span><span id="_CPPv2N19heap_trace_record_t4sizeE"></span><span id="heap_trace_record_t::size__s"></span><span class="target" id="structheap__trace__record__t_1a1a13eb467724bf28ccacb694627b6f3d"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">size</span></span></span><a class="headerlink" href="#_CPPv4N19heap_trace_record_t4sizeE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Size of the allocation. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N19heap_trace_record_t5freedE">
<span id="_CPPv3N19heap_trace_record_t5freedE"></span><span id="_CPPv2N19heap_trace_record_t5freedE"></span><span id="heap_trace_record_t::freed__b"></span><span class="target" id="structheap__trace__record__t_1a72d110f8645a37dda97ef69252eb4750"></span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">freed</span></span></span><a class="headerlink" href="#_CPPv4N19heap_trace_record_t5freedE" title="Permalink to this definition"></a><br /></dt>
<dd><p>State of the allocation (false if not freed, true if freed) </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N19heap_trace_record_t10alloced_byE">
<span id="_CPPv3N19heap_trace_record_t10alloced_byE"></span><span id="_CPPv2N19heap_trace_record_t10alloced_byE"></span><span id="heap_trace_record_t::alloced_by__voidPA"></span><span class="target" id="structheap__trace__record__t_1aa3ed0367bc373515a3d4961a7269fdf2"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">alloced_by</span></span></span><span class="p"><span class="pre">[</span></span><span class="n"><span class="pre">CONFIG_HEAP_TRACING_STACK_DEPTH</span></span><span class="p"><span class="pre">]</span></span><a class="headerlink" href="#_CPPv4N19heap_trace_record_t10alloced_byE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Call stack of the caller which allocated the memory. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N19heap_trace_record_t8freed_byE">
<span id="_CPPv3N19heap_trace_record_t8freed_byE"></span><span id="_CPPv2N19heap_trace_record_t8freed_byE"></span><span id="heap_trace_record_t::freed_by__voidPA"></span><span class="target" id="structheap__trace__record__t_1a3ad6d8c9eb49b5285a508e1ec230cea1"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">freed_by</span></span></span><span class="p"><span class="pre">[</span></span><span class="n"><span class="pre">CONFIG_HEAP_TRACING_STACK_DEPTH</span></span><span class="p"><span class="pre">]</span></span><a class="headerlink" href="#_CPPv4N19heap_trace_record_t8freed_byE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Call stack of the caller which freed the memory (all zero if not freed.) </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv420heap_trace_summary_t">
<span id="_CPPv320heap_trace_summary_t"></span><span id="_CPPv220heap_trace_summary_t"></span><span id="heap_trace_summary_t"></span><span class="target" id="structheap__trace__summary__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">heap_trace_summary_t</span></span></span><a class="headerlink" href="#_CPPv420heap_trace_summary_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Stores information about the result of a heap trace. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N20heap_trace_summary_t4modeE">
<span id="_CPPv3N20heap_trace_summary_t4modeE"></span><span id="_CPPv2N20heap_trace_summary_t4modeE"></span><span id="heap_trace_summary_t::mode__heap_trace_mode_t"></span><span class="target" id="structheap__trace__summary__t_1a4bb33a9b038d1591038dc4be323ab92c"></span><a class="reference internal" href="#_CPPv417heap_trace_mode_t" title="heap_trace_mode_t"><span class="n"><span class="pre">heap_trace_mode_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mode</span></span></span><a class="headerlink" href="#_CPPv4N20heap_trace_summary_t4modeE" title="Permalink to this definition"></a><br /></dt>
<dd><p>The heap trace mode we just completed / are running. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N20heap_trace_summary_t17total_allocationsE">
<span id="_CPPv3N20heap_trace_summary_t17total_allocationsE"></span><span id="_CPPv2N20heap_trace_summary_t17total_allocationsE"></span><span id="heap_trace_summary_t::total_allocations__s"></span><span class="target" id="structheap__trace__summary__t_1ad3f449a7671d6d546b813341c7ef2f44"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">total_allocations</span></span></span><a class="headerlink" href="#_CPPv4N20heap_trace_summary_t17total_allocationsE" title="Permalink to this definition"></a><br /></dt>
<dd><p>The total number of allocations made during tracing. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N20heap_trace_summary_t11total_freesE">
<span id="_CPPv3N20heap_trace_summary_t11total_freesE"></span><span id="_CPPv2N20heap_trace_summary_t11total_freesE"></span><span id="heap_trace_summary_t::total_frees__s"></span><span class="target" id="structheap__trace__summary__t_1a2d4ba79c244082c41632b2f9299f46be"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">total_frees</span></span></span><a class="headerlink" href="#_CPPv4N20heap_trace_summary_t11total_freesE" title="Permalink to this definition"></a><br /></dt>
<dd><p>The total number of frees made during tracing. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N20heap_trace_summary_t5countE">
<span id="_CPPv3N20heap_trace_summary_t5countE"></span><span id="_CPPv2N20heap_trace_summary_t5countE"></span><span id="heap_trace_summary_t::count__s"></span><span class="target" id="structheap__trace__summary__t_1ad280196846066da6de8c0fcec658674e"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">count</span></span></span><a class="headerlink" href="#_CPPv4N20heap_trace_summary_t5countE" title="Permalink to this definition"></a><br /></dt>
<dd><p>The number of records in the internal buffer. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N20heap_trace_summary_t8capacityE">
<span id="_CPPv3N20heap_trace_summary_t8capacityE"></span><span id="_CPPv2N20heap_trace_summary_t8capacityE"></span><span id="heap_trace_summary_t::capacity__s"></span><span class="target" id="structheap__trace__summary__t_1ab602abb4192fa346bce29aa9dea0a7b0"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">capacity</span></span></span><a class="headerlink" href="#_CPPv4N20heap_trace_summary_t8capacityE" title="Permalink to this definition"></a><br /></dt>
<dd><p>The capacity of the internal buffer. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N20heap_trace_summary_t15high_water_markE">
<span id="_CPPv3N20heap_trace_summary_t15high_water_markE"></span><span id="_CPPv2N20heap_trace_summary_t15high_water_markE"></span><span id="heap_trace_summary_t::high_water_mark__s"></span><span class="target" id="structheap__trace__summary__t_1a2e33ef2478a3037b018e22ccdb221f26"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">high_water_mark</span></span></span><a class="headerlink" href="#_CPPv4N20heap_trace_summary_t15high_water_markE" title="Permalink to this definition"></a><br /></dt>
<dd><p>The maximum value that 'count' got to. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N20heap_trace_summary_t14has_overflowedE">
<span id="_CPPv3N20heap_trace_summary_t14has_overflowedE"></span><span id="_CPPv2N20heap_trace_summary_t14has_overflowedE"></span><span id="heap_trace_summary_t::has_overflowed__s"></span><span class="target" id="structheap__trace__summary__t_1aaf53462beab90b12820d405d27bfd805"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">has_overflowed</span></span></span><a class="headerlink" href="#_CPPv4N20heap_trace_summary_t14has_overflowedE" title="Permalink to this definition"></a><br /></dt>
<dd><p>True if the internal buffer overflowed at some point. </p>
</dd></dl>

</div>
</dd></dl>

</section>
<section id="id7">
<h3>Macros<a class="headerlink" href="#id7" title="Permalink to this heading"></a></h3>
<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.CONFIG_HEAP_TRACING_STACK_DEPTH">
<span class="target" id="esp__heap__trace_8h_1a962faaf6cd044ada51170a779dd716ff"></span><span class="sig-name descname"><span class="n"><span class="pre">CONFIG_HEAP_TRACING_STACK_DEPTH</span></span></span><a class="headerlink" href="#c.CONFIG_HEAP_TRACING_STACK_DEPTH" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

</section>
<section id="type-definitions">
<h3>Type Definitions<a class="headerlink" href="#type-definitions" title="Permalink to this heading"></a></h3>
<dl class="cpp type">
<dt class="sig sig-object cpp">
<span class="target" id="esp__heap__trace_8h_1a8d683ac07b6bebc8120f6a2c42f1f3ee"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv419heap_trace_record_t" title="heap_trace_record_t"><span class="n"><span class="pre">heap_trace_record_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">heap_trace_record_t</span></span></span><br /></dt>
<dd><p>Trace record data type. Stores information about an allocated region of memory. </p>
</dd></dl>

</section>
<section id="enumerations">
<h3>Enumerations<a class="headerlink" href="#enumerations" title="Permalink to this heading"></a></h3>
<dl class="cpp enum">
<dt class="sig sig-object cpp" id="_CPPv417heap_trace_mode_t">
<span id="_CPPv317heap_trace_mode_t"></span><span id="_CPPv217heap_trace_mode_t"></span><span class="target" id="esp__heap__trace_8h_1a405bc5c6c3a6e07f82086254c944563d"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">heap_trace_mode_t</span></span></span><a class="headerlink" href="#_CPPv417heap_trace_mode_t" title="Permalink to this definition"></a><br /></dt>
<dd><p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N17heap_trace_mode_t14HEAP_TRACE_ALLE">
<span id="_CPPv3N17heap_trace_mode_t14HEAP_TRACE_ALLE"></span><span id="_CPPv2N17heap_trace_mode_t14HEAP_TRACE_ALLE"></span><span class="target" id="esp__heap__trace_8h_1a405bc5c6c3a6e07f82086254c944563da852d11079e290f8415591926a5465d0e"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">HEAP_TRACE_ALL</span></span></span><a class="headerlink" href="#_CPPv4N17heap_trace_mode_t14HEAP_TRACE_ALLE" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N17heap_trace_mode_t16HEAP_TRACE_LEAKSE">
<span id="_CPPv3N17heap_trace_mode_t16HEAP_TRACE_LEAKSE"></span><span id="_CPPv2N17heap_trace_mode_t16HEAP_TRACE_LEAKSE"></span><span class="target" id="esp__heap__trace_8h_1a405bc5c6c3a6e07f82086254c944563da8b871cc1175288956caf38a820f56930"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">HEAP_TRACE_LEAKS</span></span></span><a class="headerlink" href="#_CPPv4N17heap_trace_mode_t16HEAP_TRACE_LEAKSE" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

</dd></dl>

</section>
</section>
</section>

    <script type="text/javascript">
        function init() {
            WaveDrom.ProcessAll();
        }
        window.onload = init;
    </script>

           </div>
             <div class="articleComments">

<style>
    .expand-feedback-content {
        display: none;
    }
    .click-like-or-dislike {
        background-color: #d3d3d3;
        pointer-events: none;
    }
</style>

<script>
    function submitFeedbackForm(user_likes_document) {
        // Send to GA4 the user reaction
        gtag('event', 'user_reaction', {
            'user_likes_document': user_likes_document
        });

        if (user_likes_document === 1) {
            document.querySelector('.like-btn').classList.add('click-like-or-dislike');
            document.getElementById("expandContentLike").style.display = 'block';
        } else {
            document.querySelector('.dislike-btn').classList.add('click-like-or-dislike');
            document.getElementById("expandContent").style.display = 'block';
        }

        document.querySelector('.like-btn').style.pointerEvents = 'none';
        document.querySelector('.dislike-btn').style.pointerEvents = 'none';
    }
</script>

<hr>

<p style="text-align:center"><strong>Was this page helpful?</strong></p>
<p style="text-align:center">
    <button class="like-btn" onclick="submitFeedbackForm(1)">
        <svg aria-hidden="true" focusable="false" class="color-fg-muted" viewBox="0 0 16 16" width="16" height="16" fill="currentColor" style="display:inline-block;user-select:none;vertical-align:text-bottom;overflow:visible">
            <path d="M8.834.066c.763.087 1.5.295 2.01.884.505.581.656 1.378.656 2.3 0 .467-.087 1.119-.157 1.637L11.328 5h1.422c.603 0 1.174.085 1.668.333.508.254.911.679 1.137 1.2.453.998.438 2.447.188 4.316l-.04.306c-.105.79-.195 1.473-.313 2.033-.131.63-.315 1.209-.668 1.672C13.97 15.847 12.706 16 11 16c-1.848 0-3.234-.333-4.388-.653-.165-.045-.323-.09-.475-.133-.658-.186-1.2-.34-1.725-.415A1.75 1.75 0 0 1 2.75 16h-1A1.75 1.75 0 0 1 0 14.25v-7.5C0 5.784.784 5 1.75 5h1a1.75 1.75 0 0 1 1.514.872c.258-.105.59-.268.918-.508C5.853 4.874 6.5 4.079 6.5 2.75v-.5c0-1.202.994-2.337 2.334-2.184ZM4.5 13.3c.705.088 1.39.284 2.072.478l.441.125c1.096.305 2.334.598 3.987.598 1.794 0 2.28-.223 2.528-.549.147-.193.276-.505.394-1.07.105-.502.188-1.124.295-1.93l.04-.3c.25-1.882.189-2.933-.068-3.497a.921.921 0 0 0-.442-.48c-.208-.104-.52-.174-.997-.174H11c-.686 0-1.295-.577-1.206-1.336.023-.192.05-.39.076-.586.065-.488.13-.97.13-1.328 0-.809-.144-1.15-.288-1.316-.137-.158-.402-.304-1.048-.378C8.357 1.521 8 1.793 8 2.25v.5c0 1.922-.978 3.128-1.933 3.825a5.831 5.831 0 0 1-1.567.81ZM2.75 6.5h-1a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h1a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z"></path>
        </svg>
    </button>
    <button class="dislike-btn" onclick="submitFeedbackForm(0)">
        <svg aria-hidden="true" focusable="false" class="" viewBox="0 0 16 16" width="16" height="16" fill="currentColor" style="display:inline-block;user-select:none;vertical-align:text-bottom;overflow:visible">
            <path d="M7.083 15.986c-.763-.087-1.499-.295-2.011-.884-.504-.581-.655-1.378-.655-2.299 0-.468.087-1.12.157-1.638l.015-.112H3.167c-.603 0-1.174-.086-1.669-.334a2.415 2.415 0 0 1-1.136-1.2c-.454-.998-.438-2.447-.188-4.316l.04-.306C.32 4.108.41 3.424.526 2.864c.132-.63.316-1.209.669-1.672C1.947.205 3.211.053 4.917.053c1.848 0 3.234.332 4.388.652l.474.133c.658.187 1.201.341 1.726.415a1.75 1.75 0 0 1 1.662-1.2h1c.966 0 1.75.784 1.75 1.75v7.5a1.75 1.75 0 0 1-1.75 1.75h-1a1.75 1.75 0 0 1-1.514-.872c-.259.105-.59.268-.919.508-.671.491-1.317 1.285-1.317 2.614v.5c0 1.201-.994 2.336-2.334 2.183Zm4.334-13.232c-.706-.089-1.39-.284-2.072-.479l-.441-.125c-1.096-.304-2.335-.597-3.987-.597-1.794 0-2.28.222-2.529.548-.147.193-.275.505-.393 1.07-.105.502-.188 1.124-.295 1.93l-.04.3c-.25 1.882-.19 2.933.067 3.497a.923.923 0 0 0 .443.48c.208.104.52.175.997.175h1.75c.685 0 1.295.577 1.205 1.335-.022.192-.049.39-.075.586-.066.488-.13.97-.13 1.329 0 .808.144 1.15.288 1.316.137.157.401.303 1.048.377.307.035.664-.237.664-.693v-.5c0-1.922.978-3.127 1.932-3.825a5.878 5.878 0 0 1 1.568-.809Zm1.75 6.798h1a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25h-1a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25Z"></path>
        </svg>
    </button>
</p>

<div class="expand-feedback-content" id="expandContentLike">
    <ul style="text-align:center">
        <li>Thank you! We received your feedback.</li>
        <li>If you have any comments, fill in <a href='https://www.espressif.com/en/company/documents/documentation_feedback?docId=4287&sections=Heap Memory Debugging (api-reference/system/heap_debug)&version=esp32 latest (master)'>Espressif Documentation Feedback Form</a>.</li>
    </ul>
</div>

<div class="expand-feedback-content" id="expandContent">
    <ul style="text-align:center">
        <li>We value your feedback.</li>
        <li>Let us know how we can improve this page by filling in <a href='https://www.espressif.com/en/company/documents/documentation_feedback?docId=4287&sections=Heap Memory Debugging (api-reference/system/heap_debug)&version=esp32 latest (master)'>Espressif Documentation Feedback Form</a>.</li>
    </ul>
</div>

<br>


             </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="mm.html" class="btn btn-neutral float-left" title="Memory Management for MMU Supported Memory" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="esp_timer.html" class="btn btn-neutral float-right" title="ESP Timer (High Resolution Timer)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016 - 2025, Espressif Systems (Shanghai) Co., Ltd.</p>
  </div>

  <ul class="footer">
        <li>
	    
            
            Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/espressif/sphinx_idf_theme">theme</a>  based on <a href="https://github.com/readthedocs/sphinx_rtd_theme">Read the Docs Sphinx Theme</a>.
         </li>
    <li class="footer-aside">
        <a href="../../esp-idf-en-latest.zip"> Download HTML</a>
    </li>

  </ul> 

</footer>
        </div>
      </div>
    </section>
  </div>

  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>