<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-73KGWFC8DM"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());

            gtag('config', 'G-73KGWFC8DM');
        </script><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>General Purpose Timer (GPTimer) - ESP32 -  &mdash; ESP-IDF Programming Guide latest documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=a60756f2" />
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=949a1ff5" />
      <link rel="stylesheet" type="text/css" href="../../_static/theme_overrides.css?v=851bd809" />
      <link rel="stylesheet" type="text/css" href="../../_static/js/chatbot_widget.css?v=3106ea3a" />

  
    <link rel="canonical" href="https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/peripherals/gptimer.html" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=becddca3"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
        <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
        <script src="../../_static/copybutton.js?v=ff8fa330"></script>
        <script src="https://wavedrom.com/skins/default.js"></script>
        <script src="https://wavedrom.com/wavedrom.min.js"></script>
        <script src="../../_static/js/chatbot_widget_en.js?v=63d6728d"></script>
    <script src="../../_static/js/theme.js"></script>

    
        

    <script type="text/javascript">
        DOCUMENTATION_OPTIONS.PAGENAME = 'api-reference/peripherals/gptimer';
        DOCUMENTATION_OPTIONS.PROJECT_SLUG = 'esp-idf';
        DOCUMENTATION_OPTIONS.LATEST_BRANCH_NAME = 'master';
        DOCUMENTATION_OPTIONS.VERSIONS_URL = 'https://dl.espressif.com/dl/esp-idf/idf_versions.js';
        DOCUMENTATION_OPTIONS.LANGUAGES = ["en", "zh_CN"];
        DOCUMENTATION_OPTIONS.IDF_TARGET = 'esp32';
        DOCUMENTATION_OPTIONS.HAS_IDF_TARGETS = ["esp32", "esp32s2", "esp32s3", "esp32c3", "esp32c2", "esp32c5", "esp32c6", "esp32p4"]
        DOCUMENTATION_OPTIONS.RELEASE = 'latest';
        DOCUMENTATION_OPTIONS.LANGUAGE_URL = 'en';

    </script>

    <script type="text/javascript" src="https://dl.espressif.com/dl/esp-idf/idf_versions.js"></script>
    <link rel="author" title="About these documents" href="../../about.html" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Inter-Integrated Circuit (I2C)" href="i2c.html" />
    <link rel="prev" title="GPIO &amp; RTC GPIO" href="gpio.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            ESP-IDF Programming Guide
              <img src="../../_static/espressif-logo.svg" class="logo" alt="Logo"/>
          </a>

          
            <div class="selectors">
              <select id="target-select" style="width: 150px;" hidden>
                <option value="" disabled selected>Choose target...</option>
              </select>
            </div>
          

          <div class="selectors">
            <select id="version-select" style="width: 150px;" hidden>
              <option value="" disabled selected>Choose version...</option>
            </select>
          </div>

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../get-started/index.html">Get Started</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">API Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../api-conventions.html">API Conventions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../protocols/index.html">Application Protocols</a></li>
<li class="toctree-l2"><a class="reference internal" href="../bluetooth/index.html">Bluetooth<sup>®</sup> API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../error-codes.html">Error Codes Reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="../network/index.html">Networking APIs</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Peripherals API</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="adc/index.html">Analog to Digital Converter (ADC)</a></li>
<li class="toctree-l3"><a class="reference internal" href="clk_tree.html">Clock Tree</a></li>
<li class="toctree-l3"><a class="reference internal" href="dac.html">Digital To Analog Converter (DAC)</a></li>
<li class="toctree-l3"><a class="reference internal" href="gpio.html">GPIO &amp; RTC GPIO</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">General Purpose Timer (GPTimer)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#quick-start">Quick Start</a></li>
<li class="toctree-l4"><a class="reference internal" href="#advanced-features">Advanced Features</a></li>
<li class="toctree-l4"><a class="reference internal" href="#application-examples">Application Examples</a></li>
<li class="toctree-l4"><a class="reference internal" href="#api-reference">API Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="i2c.html">Inter-Integrated Circuit (I2C)</a></li>
<li class="toctree-l3"><a class="reference internal" href="i2s.html">Inter-IC Sound (I2S)</a></li>
<li class="toctree-l3"><a class="reference internal" href="lcd/index.html">LCD</a></li>
<li class="toctree-l3"><a class="reference internal" href="ledc.html">LED Control (LEDC)</a></li>
<li class="toctree-l3"><a class="reference internal" href="mcpwm.html">Motor Control Pulse Width Modulator (MCPWM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="pcnt.html">Pulse Counter (PCNT)</a></li>
<li class="toctree-l3"><a class="reference internal" href="rmt.html">Remote Control Transceiver (RMT)</a></li>
<li class="toctree-l3"><a class="reference internal" href="sd_pullup_requirements.html">SD Pull-up Requirements</a></li>
<li class="toctree-l3"><a class="reference internal" href="sdmmc_host.html">SDMMC Host Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="sdspi_host.html">SD SPI Host Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="sdio_slave.html">SDIO Card Slave Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="sdm.html">Sigma-Delta Modulation (SDM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="spi_flash/index.html">SPI Flash API</a></li>
<li class="toctree-l3"><a class="reference internal" href="spi_master.html">SPI Master Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="spi_slave.html">SPI Slave Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="cap_touch_sens.html">Capacitive Touch Sensor</a></li>
<li class="toctree-l3"><a class="reference internal" href="twai.html">Two-Wire Automotive Interface (TWAI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="uart.html">Universal Asynchronous Receiver/Transmitter (UART)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../provisioning/index.html">Provisioning API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../storage/index.html">Storage API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../system/index.html">System API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kconfig-reference.html">Configuration Options Reference</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../hw-reference/index.html">Hardware Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api-guides/index.html">API Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../migration-guides/index.html">Migration Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../libraries-and-frameworks/index.html">Libraries and Frameworks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contribute/index.html">Contributions Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../versions.html">ESP-IDF Versions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../resources.html">Resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../COPYRIGHT.html">Copyrights and Licenses</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../about.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../languages.html">Switch Between Languages</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">ESP-IDF Programming Guide</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">API Reference</a></li>
          <li class="breadcrumb-item"><a href="index.html">Peripherals API</a></li>
      <li class="breadcrumb-item active">General Purpose Timer (GPTimer)</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/espressif/esp-idf/blob/758939ca/docs/en/api-reference/peripherals/gptimer.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="general-purpose-timer-gptimer">
<h1>General Purpose Timer (GPTimer)<a class="headerlink" href="#general-purpose-timer-gptimer" title="Permalink to this heading"></a></h1>
<p><a class="reference external" href="../../../../../zh_CN/latest/esp32/api-reference/peripherals/gptimer.html">[中文]</a></p>
<p>This document introduces the features of the General Purpose Timer (GPTimer) driver in ESP-IDF. The table of contents is as follows:</p>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#overview" id="id6">Overview</a></p></li>
<li><p><a class="reference internal" href="#quick-start" id="id7">Quick Start</a></p>
<ul>
<li><p><a class="reference internal" href="#creating-and-starting-a-timer" id="id8">Creating and Starting a Timer</a></p></li>
<li><p><a class="reference internal" href="#setting-and-getting-the-count-value" id="id9">Setting and Getting the Count Value</a></p></li>
<li><p><a class="reference internal" href="#triggering-periodic-alarm-events" id="id10">Triggering Periodic Alarm Events</a></p></li>
<li><p><a class="reference internal" href="#triggering-one-shot-alarm-events" id="id11">Triggering One-Shot Alarm Events</a></p></li>
<li><p><a class="reference internal" href="#resource-recycling" id="id12">Resource Recycling</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#advanced-features" id="id13">Advanced Features</a></p>
<ul>
<li><p><a class="reference internal" href="#dynamic-alarm-value-update" id="id14">Dynamic Alarm Value Update</a></p></li>
<li><p><a class="reference internal" href="#power-management" id="id15">Power Management</a></p></li>
<li><p><a class="reference internal" href="#thread-safety" id="id16">Thread Safety</a></p></li>
<li><p><a class="reference internal" href="#cache-safety" id="id17">Cache Safety</a></p></li>
<li><p><a class="reference internal" href="#performance" id="id18">Performance</a></p></li>
<li><p><a class="reference internal" href="#other-kconfig-options" id="id19">Other Kconfig Options</a></p></li>
<li><p><a class="reference internal" href="#resource-consumption" id="id20">Resource Consumption</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#application-examples" id="id21">Application Examples</a></p></li>
<li><p><a class="reference internal" href="#api-reference" id="id22">API Reference</a></p>
<ul>
<li><p><a class="reference internal" href="#header-file" id="id23">Header File</a></p></li>
<li><p><a class="reference internal" href="#functions" id="id24">Functions</a></p></li>
<li><p><a class="reference internal" href="#structures" id="id25">Structures</a></p></li>
<li><p><a class="reference internal" href="#id1" id="id26">Header File</a></p></li>
<li><p><a class="reference internal" href="#id2" id="id27">Structures</a></p></li>
<li><p><a class="reference internal" href="#type-definitions" id="id28">Type Definitions</a></p></li>
<li><p><a class="reference internal" href="#id3" id="id29">Header File</a></p></li>
<li><p><a class="reference internal" href="#id4" id="id30">Type Definitions</a></p></li>
<li><p><a class="reference internal" href="#enumerations" id="id31">Enumerations</a></p></li>
</ul>
</li>
</ul>
</nav>
<section id="overview">
<h2><a class="toc-backref" href="#id6" role="doc-backlink">Overview</a><a class="headerlink" href="#overview" title="Permalink to this heading"></a></h2>
<p>GPTimer is a dedicated driver for the ESP32 [<a class="reference external" href="https://www.espressif.com/sites/default/files/documentation/esp32_technical_reference_manual_en.pdf#timg">Timer Group peripheral</a>]. This timer can select different clock sources and prescalers to meet the requirements of nanosecond-level resolution. Additionally, it has flexible timeout alarm functions and allows automatic updating of the count value at the alarm moment, achieving very precise timing cycles.</p>
<p>Based on the <strong>high resolution, high count range, and high response</strong> capabilities of the hardware timer, the main application scenarios of this driver include:</p>
<ul class="simple">
<li><p>Running freely as a calendar clock to provide timestamp services for other modules</p></li>
<li><p>Generating periodic alarms to complete periodic tasks</p></li>
<li><p>Generating one-shot alarms, which can be used to implement a monotonic software timer list with asynchronous updates of alarm values</p></li>
<li><p>Working with the GPIO module to achieve PWM signal output and input capture</p></li>
<li><p>etc.</p></li>
</ul>
</section>
<section id="quick-start">
<h2><a class="toc-backref" href="#id7" role="doc-backlink">Quick Start</a><a class="headerlink" href="#quick-start" title="Permalink to this heading"></a></h2>
<p>This section provides a concise overview of how to use the GPTimer driver. Through practical examples, it demonstrates how to initialize and start a timer, configure alarm events, and register callback functions. The typical usage flow is as follows:</p>
<figure class="align-center" id="id5">
<div class="align-default"><a class="reference internal image-reference" href="../../_images/blockdiag-ceda78164efaf3035a729f1110ddb2f9f14384ff.png"><img height="400.0" src="../../_images/blockdiag-ceda78164efaf3035a729f1110ddb2f9f14384ff.png" width="1006.0" /></a></div>
<figcaption>
<p><span class="caption-text">GPTimer driver's general usage flow (click to enlarge)</span><a class="headerlink" href="#id5" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<section id="creating-and-starting-a-timer">
<h3><a class="toc-backref" href="#id8" role="doc-backlink">Creating and Starting a Timer</a><a class="headerlink" href="#creating-and-starting-a-timer" title="Permalink to this heading"></a></h3>
<p>First, we need to create a timer instance. The following code shows how to create a timer with a resolution of 1 MHz:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">gptimer_handle_t</span><span class="w"> </span><span class="n">gptimer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="n">gptimer_config_t</span><span class="w"> </span><span class="n">timer_config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">clk_src</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GPTIMER_CLK_SRC_DEFAULT</span><span class="p">,</span><span class="w"> </span><span class="c1">// Select the default clock source</span>
<span class="w">    </span><span class="p">.</span><span class="n">direction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GPTIMER_COUNT_UP</span><span class="p">,</span><span class="w">      </span><span class="c1">// Counting direction is up</span>
<span class="w">    </span><span class="p">.</span><span class="n">resolution_hz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1000</span><span class="p">,</span><span class="w">   </span><span class="c1">// Resolution is 1 MHz, i.e., 1 tick equals 1 microsecond</span>
<span class="p">};</span>
<span class="c1">// Create a timer instance</span>
<span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">gptimer_new_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer_config</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">gptimer</span><span class="p">));</span>
<span class="c1">// Enable the timer</span>
<span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">gptimer_enable</span><span class="p">(</span><span class="n">gptimer</span><span class="p">));</span>
<span class="c1">// Start the timer</span>
<span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">gptimer_start</span><span class="p">(</span><span class="n">gptimer</span><span class="p">));</span>
</pre></div>
</div>
<p>When creating a timer instance, we need to configure parameters such as the clock source, counting direction, and resolution through <a class="reference internal" href="#_CPPv416gptimer_config_t" title="gptimer_config_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">gptimer_config_t</span></code></a>. These parameters determine how the timer works. Then, call the <a class="reference internal" href="#_CPPv417gptimer_new_timerPK16gptimer_config_tP16gptimer_handle_t" title="gptimer_new_timer"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">gptimer_new_timer()</span></code></a> function to create a new timer instance, which returns a handle pointing to the new instance. The timer handle is essentially a pointer to the timer memory object, of type <a class="reference internal" href="#_CPPv416gptimer_handle_t" title="gptimer_handle_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">gptimer_handle_t</span></code></a>.</p>
<p>Here are the other configuration parameters of the <a class="reference internal" href="#_CPPv416gptimer_config_t" title="gptimer_config_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">gptimer_config_t</span></code></a> structure and their explanations:</p>
<ul>
<li><p><a class="reference internal" href="#_CPPv4N16gptimer_config_t7clk_srcE" title="gptimer_config_t::clk_src"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">gptimer_config_t::clk_src</span></code></a> selects the clock source for the timer. Available clock sources are listed in <a class="reference internal" href="#_CPPv422gptimer_clock_source_t" title="gptimer_clock_source_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">gptimer_clock_source_t</span></code></a>, and only one can be selected. Different clock sources vary in resolution, accuracy, and power consumption.</p></li>
<li><p><a class="reference internal" href="#_CPPv4N16gptimer_config_t9directionE" title="gptimer_config_t::direction"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">gptimer_config_t::direction</span></code></a> sets the counting direction of the timer. Supported directions are listed in <a class="reference internal" href="#_CPPv425gptimer_count_direction_t" title="gptimer_count_direction_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">gptimer_count_direction_t</span></code></a>, and only one can be selected.</p></li>
<li><p><a class="reference internal" href="#_CPPv4N16gptimer_config_t13resolution_hzE" title="gptimer_config_t::resolution_hz"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">gptimer_config_t::resolution_hz</span></code></a> sets the resolution of the internal counter. Each tick is equivalent to <strong>1 / resolution_hz</strong> seconds.</p></li>
<li><p><a class="reference internal" href="#_CPPv4N16gptimer_config_t13intr_priorityE" title="gptimer_config_t::intr_priority"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">gptimer_config_t::intr_priority</span></code></a> sets the interrupt priority. If set to <code class="docutils literal notranslate"><span class="pre">0</span></code>, a default priority interrupt will be allocated; otherwise, the specified priority will be used.</p></li>
<li><p><a class="reference internal" href="#_CPPv4N16gptimer_config_t5flagsE" title="gptimer_config_t::flags"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">gptimer_config_t::flags</span></code></a> is used to fine-tune some behaviors of the driver, including the following options:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">gptimer_config_t::flags::allow_pd</span></code> configures whether the driver allows the system to power down the peripheral in sleep mode. Before entering sleep, the system will back up the GPTimer register context, which will be restored when the system wakes up. Note that powering down the peripheral can save power but will consume more memory to save the register context. You need to balance power consumption and memory usage. This configuration option depends on specific hardware features. If enabled on an unsupported chip, you will see an error message like <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">able</span> <span class="pre">to</span> <span class="pre">power</span> <span class="pre">down</span> <span class="pre">in</span> <span class="pre">light</span> <span class="pre">sleep</span></code>.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Note that if all hardware timers in the current chip have been allocated, <a class="reference internal" href="#_CPPv417gptimer_new_timerPK16gptimer_config_tP16gptimer_handle_t" title="gptimer_new_timer"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">gptimer_new_timer()</span></code></a> will return the <a class="reference internal" href="../system/esp_err.html#c.ESP_ERR_NOT_FOUND" title="ESP_ERR_NOT_FOUND"><code class="xref c c-macro docutils literal notranslate"><span class="pre">ESP_ERR_NOT_FOUND</span></code></a> error.</p>
</div>
<p>Before starting the timer, it must be enabled. The enable function <a class="reference internal" href="#_CPPv414gptimer_enable16gptimer_handle_t" title="gptimer_enable"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">gptimer_enable()</span></code></a> can switch the internal state machine of the driver to the active state, which includes some system service requests/registrations, such as applying for a power management lock. The corresponding disable function is <a class="reference internal" href="#_CPPv415gptimer_disable16gptimer_handle_t" title="gptimer_disable"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">gptimer_disable()</span></code></a>, which releases all system services.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When calling the <a class="reference internal" href="#_CPPv414gptimer_enable16gptimer_handle_t" title="gptimer_enable"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">gptimer_enable()</span></code></a> and <a class="reference internal" href="#_CPPv415gptimer_disable16gptimer_handle_t" title="gptimer_disable"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">gptimer_disable()</span></code></a> functions, they need to be used in pairs. This means you cannot call <a class="reference internal" href="#_CPPv414gptimer_enable16gptimer_handle_t" title="gptimer_enable"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">gptimer_enable()</span></code></a> or <a class="reference internal" href="#_CPPv415gptimer_disable16gptimer_handle_t" title="gptimer_disable"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">gptimer_disable()</span></code></a> twice in a row. This pairing principle ensures the correct management and release of resources.</p>
</div>
<p>The <a class="reference internal" href="#_CPPv413gptimer_start16gptimer_handle_t" title="gptimer_start"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">gptimer_start()</span></code></a> function is used to start the timer. After starting, the timer will begin counting and will automatically overflow and restart from 0 when it reaches the maximum or minimum value (depending on the counting direction).
The <a class="reference internal" href="#_CPPv412gptimer_stop16gptimer_handle_t" title="gptimer_stop"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">gptimer_stop()</span></code></a> function is used to stop the timer. Note that stopping a timer does not clear the current value of the counter. To clear the counter, use the <a class="reference internal" href="#_CPPv421gptimer_set_raw_count16gptimer_handle_t8uint64_t" title="gptimer_set_raw_count"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">gptimer_set_raw_count()</span></code></a> function introduced later.
The <a class="reference internal" href="#_CPPv413gptimer_start16gptimer_handle_t" title="gptimer_start"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">gptimer_start()</span></code></a> and <a class="reference internal" href="#_CPPv412gptimer_stop16gptimer_handle_t" title="gptimer_stop"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">gptimer_stop()</span></code></a> functions follow the idempotent principle. This means that if the timer is already started, calling the <a class="reference internal" href="#_CPPv413gptimer_start16gptimer_handle_t" title="gptimer_start"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">gptimer_start()</span></code></a> function again will have no effect. Similarly, if the timer is already stopped, calling the <a class="reference internal" href="#_CPPv412gptimer_stop16gptimer_handle_t" title="gptimer_stop"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">gptimer_stop()</span></code></a> function again will have no effect.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>However, note that when the timer is in the <strong>intermediate state</strong> of starting (the start has begun but not yet completed), if another thread calls the <a class="reference internal" href="#_CPPv413gptimer_start16gptimer_handle_t" title="gptimer_start"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">gptimer_start()</span></code></a> or <a class="reference internal" href="#_CPPv412gptimer_stop16gptimer_handle_t" title="gptimer_stop"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">gptimer_stop()</span></code></a> function, it will return the <a class="reference internal" href="../system/esp_err.html#c.ESP_ERR_INVALID_STATE" title="ESP_ERR_INVALID_STATE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">ESP_ERR_INVALID_STATE</span></code></a> error to avoid triggering uncertain behavior.</p>
</div>
</section>
<section id="setting-and-getting-the-count-value">
<h3><a class="toc-backref" href="#id9" role="doc-backlink">Setting and Getting the Count Value</a><a class="headerlink" href="#setting-and-getting-the-count-value" title="Permalink to this heading"></a></h3>
<p>When a timer is newly created, its internal counter value defaults to zero. You can set other count values using the <a class="reference internal" href="#_CPPv421gptimer_set_raw_count16gptimer_handle_t8uint64_t" title="gptimer_set_raw_count"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">gptimer_set_raw_count()</span></code></a> function. The maximum count value depends on the bit width of the hardware timer (usually no less than <code class="docutils literal notranslate"><span class="pre">54</span> <span class="pre">bits</span></code>).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the timer is already running, <a class="reference internal" href="#_CPPv421gptimer_set_raw_count16gptimer_handle_t8uint64_t" title="gptimer_set_raw_count"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">gptimer_set_raw_count()</span></code></a> will make the timer immediately jump to the new value and start counting from the newly set value.</p>
</div>
<p>The <a class="reference internal" href="#_CPPv421gptimer_get_raw_count16gptimer_handle_tP8uint64_t" title="gptimer_get_raw_count"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">gptimer_get_raw_count()</span></code></a> function is used to get the current count value of the timer. This count value is the accumulated count since the timer started (assuming it started from 0). Note that the returned value has not been converted to any unit; it is a pure count value. You need to convert the count value to time units based on the actual resolution of the timer. The timer's resolution can be obtained using the <a class="reference internal" href="#_CPPv422gptimer_get_resolution16gptimer_handle_tP8uint32_t" title="gptimer_get_resolution"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">gptimer_get_resolution()</span></code></a> function.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Check the timer&#39;s resolution</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">resolution_hz</span><span class="p">;</span>
<span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">gptimer_get_resolution</span><span class="p">(</span><span class="n">gptimer</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">resolution_hz</span><span class="p">));</span>
<span class="c1">// Read the current count value</span>
<span class="kt">uint64_t</span><span class="w"> </span><span class="n">count</span><span class="p">;</span>
<span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">gptimer_get_raw_count</span><span class="p">(</span><span class="n">gptimer</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">count</span><span class="p">));</span>
<span class="c1">// (Optional) Convert the count value to time units (seconds)</span>
<span class="kt">double</span><span class="w"> </span><span class="n">time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">count</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">resolution_hz</span><span class="p">;</span>
</pre></div>
</div>
</section>
<section id="triggering-periodic-alarm-events">
<h3><a class="toc-backref" href="#id10" role="doc-backlink">Triggering Periodic Alarm Events</a><a class="headerlink" href="#triggering-periodic-alarm-events" title="Permalink to this heading"></a></h3>
<p>In addition to the timestamp function, the general-purpose timer also supports alarm functions. The following code shows how to set a periodic alarm that triggers once per second:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">gptimer_handle_t</span><span class="w"> </span><span class="n">gptimer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="n">gptimer_config_t</span><span class="w"> </span><span class="n">timer_config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">clk_src</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GPTIMER_CLK_SRC_DEFAULT</span><span class="p">,</span><span class="w"> </span><span class="c1">// Select the default clock source</span>
<span class="w">    </span><span class="p">.</span><span class="n">direction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GPTIMER_COUNT_UP</span><span class="p">,</span><span class="w">      </span><span class="c1">// Counting direction is up</span>
<span class="w">    </span><span class="p">.</span><span class="n">resolution_hz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1000</span><span class="p">,</span><span class="w">   </span><span class="c1">// Resolution is 1 MHz, i.e., 1 tick equals 1 microsecond</span>
<span class="p">};</span>
<span class="c1">// Create a timer instance</span>
<span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">gptimer_new_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer_config</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">gptimer</span><span class="p">));</span>

<span class="hll"><span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">example_timer_on_alarm_cb</span><span class="p">(</span><span class="n">gptimer_handle_t</span><span class="w"> </span><span class="n">timer</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">gptimer_alarm_event_data_t</span><span class="w"> </span><span class="o">*</span><span class="n">edata</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">user_ctx</span><span class="p">)</span>
</span><span class="hll"><span class="p">{</span>
</span><span class="hll"><span class="w">    </span><span class="c1">// General process for handling event callbacks:</span>
</span><span class="hll"><span class="w">    </span><span class="c1">// 1. Retrieve user context data from user_ctx (passed in from gptimer_register_event_callbacks)</span>
</span><span class="hll"><span class="w">    </span><span class="c1">// 2. Get alarm event data from edata, such as edata-&gt;count_value</span>
</span><span class="hll"><span class="w">    </span><span class="c1">// 3. Perform user-defined operations</span>
</span><span class="hll"><span class="w">    </span><span class="c1">// 4. Return whether a high-priority task was awakened during the above operations to notify the scheduler to switch tasks</span>
</span><span class="hll"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
</span><span class="hll"><span class="p">}</span>
</span><span class="hll">
</span><span class="hll"><span class="n">gptimer_alarm_config_t</span><span class="w"> </span><span class="n">alarm_config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
</span><span class="hll"><span class="w">    </span><span class="p">.</span><span class="n">reload_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">      </span><span class="c1">// When the alarm event occurs, the timer will automatically reload to 0</span>
</span><span class="hll"><span class="w">    </span><span class="p">.</span><span class="n">alarm_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1000000</span><span class="p">,</span><span class="w"> </span><span class="c1">// Set the actual alarm period, since the resolution is 1us, 1000000 represents 1s</span>
</span><span class="hll"><span class="w">    </span><span class="p">.</span><span class="n">flags</span><span class="p">.</span><span class="n">auto_reload_on_alarm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="c1">// Enable auto-reload function</span>
</span><span class="hll"><span class="p">};</span>
</span><span class="hll"><span class="c1">// Set the timer&#39;s alarm action</span>
</span><span class="hll"><span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">gptimer_set_alarm_action</span><span class="p">(</span><span class="n">gptimer</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">alarm_config</span><span class="p">));</span>
</span><span class="hll">
</span><span class="hll"><span class="n">gptimer_event_callbacks_t</span><span class="w"> </span><span class="n">cbs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
</span><span class="hll"><span class="w">    </span><span class="p">.</span><span class="n">on_alarm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">example_timer_on_alarm_cb</span><span class="p">,</span><span class="w"> </span><span class="c1">// Call the user callback function when the alarm event occurs</span>
</span><span class="hll"><span class="p">};</span>
</span><span class="hll"><span class="c1">// Register timer event callback functions, allowing user context to be carried</span>
</span><span class="hll"><span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">gptimer_register_event_callbacks</span><span class="p">(</span><span class="n">gptimer</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cbs</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">));</span>
</span><span class="c1">// Enable the timer</span>
<span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">gptimer_enable</span><span class="p">(</span><span class="n">gptimer</span><span class="p">));</span>
<span class="c1">// Start the timer</span>
<span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">gptimer_start</span><span class="p">(</span><span class="n">gptimer</span><span class="p">));</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="#_CPPv424gptimer_set_alarm_action16gptimer_handle_tPK22gptimer_alarm_config_t" title="gptimer_set_alarm_action"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">gptimer_set_alarm_action()</span></code></a> function is used to configure the timer's alarm action. When the timer count value reaches the specified alarm value, an alarm event will be triggered. Users can choose to automatically reload the preset count value when the alarm event occurs, thereby achieving periodic alarms.</p>
<p>Here are the necessary members of the <a class="reference internal" href="#_CPPv422gptimer_alarm_config_t" title="gptimer_alarm_config_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">gptimer_alarm_config_t</span></code></a> structure and their functions. By configuring these parameters, users can flexibly control the timer's alarm behavior to meet different application needs.</p>
<ul class="simple">
<li><p><a class="reference internal" href="#_CPPv4N22gptimer_alarm_config_t11alarm_countE" title="gptimer_alarm_config_t::alarm_count"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">gptimer_alarm_config_t::alarm_count</span></code></a> sets the target count value that triggers the alarm event. When the timer count value reaches this value, an alarm event will be triggered. When setting the alarm value, consider the counting direction of the timer. If the current count value has <strong>exceeded</strong> the alarm value, the alarm event will be triggered immediately.</p></li>
<li><p><a class="reference internal" href="#_CPPv4N22gptimer_alarm_config_t12reload_countE" title="gptimer_alarm_config_t::reload_count"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">gptimer_alarm_config_t::reload_count</span></code></a> sets the count value to be reloaded when the alarm event occurs. This configuration only takes effect when the <code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">gptimer_alarm_config_t::flags::auto_reload_on_alarm</span></code> flag is <code class="docutils literal notranslate"><span class="pre">true</span></code>. The actual alarm period will be determined by <code class="docutils literal notranslate"><span class="pre">|alarm_count</span> <span class="pre">-</span> <span class="pre">reload_count|</span></code>. From a practical application perspective, it is not recommended to set the alarm period to less than 5us.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Specifically, <code class="docutils literal notranslate"><span class="pre">gptimer_set_alarm_action(gptimer,</span> <span class="pre">NULL);</span></code> means disabling the timer's alarm function.</p>
</div>
<p>The <a class="reference internal" href="#_CPPv432gptimer_register_event_callbacks16gptimer_handle_tPK25gptimer_event_callbacks_tPv" title="gptimer_register_event_callbacks"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">gptimer_register_event_callbacks()</span></code></a> function is used to register the timer event callback functions. When the timer triggers a specific event (such as an alarm event), the user-defined callback function will be called. Users can perform custom operations in the callback function, such as sending signals, to achieve more flexible event handling mechanisms. Since the callback function is executed in the interrupt context, avoid performing complex operations (including any operations that may cause blocking) in the callback function to avoid affecting the system's real-time performance. The <a class="reference internal" href="#_CPPv432gptimer_register_event_callbacks16gptimer_handle_tPK25gptimer_event_callbacks_tPv" title="gptimer_register_event_callbacks"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">gptimer_register_event_callbacks()</span></code></a> function also allows users to pass a context pointer to access user-defined data in the callback function.</p>
<p>The supported event callback functions for GPTimer are as follows:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#_CPPv418gptimer_alarm_cb_t" title="gptimer_alarm_cb_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">gptimer_alarm_cb_t</span></code></a> alarm event callback function, which has a corresponding data structure <a class="reference internal" href="#_CPPv426gptimer_alarm_event_data_t" title="gptimer_alarm_event_data_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">gptimer_alarm_event_data_t</span></code></a> for passing alarm event-related data:
- <a class="reference internal" href="#_CPPv4N26gptimer_alarm_event_data_t11alarm_valueE" title="gptimer_alarm_event_data_t::alarm_value"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">gptimer_alarm_event_data_t::alarm_value</span></code></a> stores the alarm value, which is the target count value that triggers the alarm event.
- <a class="reference internal" href="#_CPPv4N26gptimer_alarm_event_data_t11count_valueE" title="gptimer_alarm_event_data_t::count_value"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">gptimer_alarm_event_data_t::count_value</span></code></a> stores the count value when entering the interrupt handler after the alarm occurs. This value may differ from the alarm value due to interrupt handler delays, and the count value may have been automatically reloaded when the alarm occurred.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Be sure to register the callback function before calling <a class="reference internal" href="#_CPPv414gptimer_enable16gptimer_handle_t" title="gptimer_enable"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">gptimer_enable()</span></code></a>, otherwise the timer event will not correctly trigger the interrupt service.</p>
</div>
</section>
<section id="triggering-one-shot-alarm-events">
<h3><a class="toc-backref" href="#id11" role="doc-backlink">Triggering One-Shot Alarm Events</a><a class="headerlink" href="#triggering-one-shot-alarm-events" title="Permalink to this heading"></a></h3>
<p>Some application scenarios only require triggering a one-shot alarm interrupt. The following code shows how to set a one-shot alarm that triggers after 1 second:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">gptimer_handle_t</span><span class="w"> </span><span class="n">gptimer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="n">gptimer_config_t</span><span class="w"> </span><span class="n">timer_config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">clk_src</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GPTIMER_CLK_SRC_DEFAULT</span><span class="p">,</span><span class="w"> </span><span class="c1">// Select the default clock source</span>
<span class="w">    </span><span class="p">.</span><span class="n">direction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GPTIMER_COUNT_UP</span><span class="p">,</span><span class="w">      </span><span class="c1">// Counting direction is up</span>
<span class="w">    </span><span class="p">.</span><span class="n">resolution_hz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1000</span><span class="p">,</span><span class="w">   </span><span class="c1">// Resolution is 1 MHz, i.e., 1 tick equals 1 microsecond</span>
<span class="p">};</span>
<span class="c1">// Create a timer instance</span>
<span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">gptimer_new_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer_config</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">gptimer</span><span class="p">));</span>

<span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">example_timer_on_alarm_cb</span><span class="p">(</span><span class="n">gptimer_handle_t</span><span class="w"> </span><span class="n">timer</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">gptimer_alarm_event_data_t</span><span class="w"> </span><span class="o">*</span><span class="n">edata</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">user_ctx</span><span class="p">)</span>
<span class="p">{</span>
<span class="hll"><span class="w">    </span><span class="c1">// This is just a demonstration of how to stop the timer when the alarm occurs for the first time</span>
</span><span class="hll"><span class="w">    </span><span class="n">gptimer_stop</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
</span><span class="w">    </span><span class="c1">// General process for handling event callbacks:</span>
<span class="w">    </span><span class="c1">// 1. Retrieve user context data from user_ctx (passed in from gptimer_register_event_callbacks)</span>
<span class="w">    </span><span class="c1">// 2. Get alarm event data from edata, such as edata-&gt;count_value</span>
<span class="w">    </span><span class="c1">// 3. Perform user-defined operations</span>
<span class="w">    </span><span class="c1">// 4. Return whether a high-priority task was awakened during the above operations to notify the scheduler to switch tasks</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">gptimer_alarm_config_t</span><span class="w"> </span><span class="n">alarm_config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">alarm_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1000000</span><span class="p">,</span><span class="w"> </span><span class="c1">// Set the actual alarm period, since the resolution is 1us, 1000000 represents 1s</span>
<span class="hll"><span class="w">    </span><span class="p">.</span><span class="n">flags</span><span class="p">.</span><span class="n">auto_reload_on_alarm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// Disable auto-reload function</span>
</span><span class="p">};</span>
<span class="c1">// Set the timer&#39;s alarm action</span>
<span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">gptimer_set_alarm_action</span><span class="p">(</span><span class="n">gptimer</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">alarm_config</span><span class="p">));</span>

<span class="n">gptimer_event_callbacks_t</span><span class="w"> </span><span class="n">cbs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">on_alarm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">example_timer_on_alarm_cb</span><span class="p">,</span><span class="w"> </span><span class="c1">// Call the user callback function when the alarm event occurs</span>
<span class="p">};</span>
<span class="c1">// Register timer event callback functions, allowing user context to be carried</span>
<span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">gptimer_register_event_callbacks</span><span class="p">(</span><span class="n">gptimer</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cbs</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">));</span>
<span class="c1">// Enable the timer</span>
<span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">gptimer_enable</span><span class="p">(</span><span class="n">gptimer</span><span class="p">));</span>
<span class="c1">// Start the timer</span>
<span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">gptimer_start</span><span class="p">(</span><span class="n">gptimer</span><span class="p">));</span>
</pre></div>
</div>
<p>Unlike periodic alarms, the above code disables the auto-reload function when configuring the alarm behavior. This means that after the alarm event occurs, the timer will not automatically reload to the preset count value but will continue counting until it overflows. If you want the timer to stop immediately after the alarm, you can call <a class="reference internal" href="#_CPPv412gptimer_stop16gptimer_handle_t" title="gptimer_stop"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">gptimer_stop()</span></code></a> in the callback function.</p>
</section>
<section id="resource-recycling">
<h3><a class="toc-backref" href="#id12" role="doc-backlink">Resource Recycling</a><a class="headerlink" href="#resource-recycling" title="Permalink to this heading"></a></h3>
<p>When the timer is no longer needed, you should call the <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">gptimer_delete_timer()</span></code> function to release software and hardware resources. Before deleting, ensure that the timer is already stopped.</p>
</section>
</section>
<section id="advanced-features">
<h2><a class="toc-backref" href="#id13" role="doc-backlink">Advanced Features</a><a class="headerlink" href="#advanced-features" title="Permalink to this heading"></a></h2>
<p>After understanding the basic usage, we can further explore more features of the GPTimer driver.</p>
<section id="dynamic-alarm-value-update">
<h3><a class="toc-backref" href="#id14" role="doc-backlink">Dynamic Alarm Value Update</a><a class="headerlink" href="#dynamic-alarm-value-update" title="Permalink to this heading"></a></h3>
<p>The GPTimer driver supports dynamically updating the alarm value in the interrupt callback function by calling the <a class="reference internal" href="#_CPPv424gptimer_set_alarm_action16gptimer_handle_tPK22gptimer_alarm_config_t" title="gptimer_set_alarm_action"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">gptimer_set_alarm_action()</span></code></a> function, thereby implementing a monotonic software timer list. The following code shows how to reset the next alarm trigger time when the alarm event occurs:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">gptimer_handle_t</span><span class="w"> </span><span class="n">gptimer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="n">gptimer_config_t</span><span class="w"> </span><span class="n">timer_config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">clk_src</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GPTIMER_CLK_SRC_DEFAULT</span><span class="p">,</span><span class="w"> </span><span class="c1">// Select the default clock source</span>
<span class="w">    </span><span class="p">.</span><span class="n">direction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GPTIMER_COUNT_UP</span><span class="p">,</span><span class="w">      </span><span class="c1">// Counting direction is up</span>
<span class="w">    </span><span class="p">.</span><span class="n">resolution_hz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1000</span><span class="p">,</span><span class="w">   </span><span class="c1">// Resolution is 1 MHz, i.e., 1 tick equals 1 microsecond</span>
<span class="p">};</span>
<span class="c1">// Create a timer instance</span>
<span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">gptimer_new_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer_config</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">gptimer</span><span class="p">));</span>

<span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">example_timer_on_alarm_cb</span><span class="p">(</span><span class="n">gptimer_handle_t</span><span class="w"> </span><span class="n">timer</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">gptimer_alarm_event_data_t</span><span class="w"> </span><span class="o">*</span><span class="n">edata</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">user_ctx</span><span class="p">)</span>
<span class="p">{</span>
<span class="hll"><span class="w">    </span><span class="n">gptimer_alarm_config_t</span><span class="w"> </span><span class="n">alarm_config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
</span><span class="hll"><span class="w">        </span><span class="p">.</span><span class="n">alarm_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">edata</span><span class="o">-&gt;</span><span class="n">alarm_value</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1000000</span><span class="p">,</span><span class="w"> </span><span class="c1">// Next alarm in 1s from the current alarm</span>
</span><span class="hll"><span class="w">    </span><span class="p">};</span>
</span><span class="hll"><span class="w">    </span><span class="c1">// Update the alarm value</span>
</span><span class="hll"><span class="w">    </span><span class="n">gptimer_set_alarm_action</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">alarm_config</span><span class="p">);</span>
</span><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">gptimer_alarm_config_t</span><span class="w"> </span><span class="n">alarm_config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">alarm_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1000000</span><span class="p">,</span><span class="w"> </span><span class="c1">// Set the actual alarm period, since the resolution is 1us, 1000000 represents 1s</span>
<span class="w">    </span><span class="p">.</span><span class="n">flags</span><span class="p">.</span><span class="n">auto_reload_on_alarm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="c1">// Disable auto-reload function</span>
<span class="p">};</span>
<span class="c1">// Set the timer&#39;s alarm action</span>
<span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">gptimer_set_alarm_action</span><span class="p">(</span><span class="n">gptimer</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">alarm_config</span><span class="p">));</span>

<span class="n">gptimer_event_callbacks_t</span><span class="w"> </span><span class="n">cbs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">on_alarm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">example_timer_on_alarm_cb</span><span class="p">,</span><span class="w"> </span><span class="c1">// Call the user callback function when the alarm event occurs</span>
<span class="p">};</span>
<span class="c1">// Register timer event callback functions, allowing user context to be carried</span>
<span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">gptimer_register_event_callbacks</span><span class="p">(</span><span class="n">gptimer</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cbs</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">));</span>
<span class="c1">// Enable the timer</span>
<span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">gptimer_enable</span><span class="p">(</span><span class="n">gptimer</span><span class="p">));</span>
<span class="c1">// Start the timer</span>
<span class="n">ESP_ERROR_CHECK</span><span class="p">(</span><span class="n">gptimer_start</span><span class="p">(</span><span class="n">gptimer</span><span class="p">));</span>
</pre></div>
</div>
</section>
<section id="power-management">
<h3><a class="toc-backref" href="#id15" role="doc-backlink">Power Management</a><a class="headerlink" href="#power-management" title="Permalink to this heading"></a></h3>
<p>When power management <a class="reference internal" href="../kconfig-reference.html#config-pm-enable"><span class="std std-ref">CONFIG_PM_ENABLE</span></a> is enabled, the system may adjust or disable the clock source before entering sleep mode, causing the GPTimer to lose accuracy.</p>
<p>To prevent this, the GPTimer driver creates a power management lock internally. When the <a class="reference internal" href="#_CPPv414gptimer_enable16gptimer_handle_t" title="gptimer_enable"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">gptimer_enable()</span></code></a> function is called, the lock is activated to ensure the system does not enter sleep mode, thus maintaining the timer's accuracy. To reduce power consumption, you can call the <a class="reference internal" href="#_CPPv415gptimer_disable16gptimer_handle_t" title="gptimer_disable"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">gptimer_disable()</span></code></a> function to release the power management lock, allowing the system to enter sleep mode. However, this will stop the timer, so you need to restart the timer after waking up.</p>
</section>
<section id="thread-safety">
<h3><a class="toc-backref" href="#id16" role="doc-backlink">Thread Safety</a><a class="headerlink" href="#thread-safety" title="Permalink to this heading"></a></h3>
<p>The driver uses critical sections to ensure atomic operations on registers. Key members in the driver handle are also protected by critical sections. The driver's internal state machine uses atomic instructions to ensure thread safety, with state checks preventing certain invalid concurrent operations (e.g., conflicts between <cite>start</cite> and <cite>stop</cite>). Therefore, GPTimer driver APIs can be used in a multi-threaded environment without extra locking.</p>
<p>The following functions can also be used in an interrupt context:</p>
<p><ul class="simple">
<li><p><a class="reference internal" href="#_CPPv413gptimer_start16gptimer_handle_t" title="gptimer_start"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">gptimer_start()</span></code></a></p></li>
<li><p><a class="reference internal" href="#_CPPv412gptimer_stop16gptimer_handle_t" title="gptimer_stop"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">gptimer_stop()</span></code></a></p></li>
<li><p><a class="reference internal" href="#_CPPv421gptimer_get_raw_count16gptimer_handle_tP8uint64_t" title="gptimer_get_raw_count"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">gptimer_get_raw_count()</span></code></a></p></li>
<li><p><a class="reference internal" href="#_CPPv421gptimer_set_raw_count16gptimer_handle_t8uint64_t" title="gptimer_set_raw_count"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">gptimer_set_raw_count()</span></code></a></p></li>
<li><p><a class="reference internal" href="#_CPPv426gptimer_get_captured_count16gptimer_handle_tP8uint64_t" title="gptimer_get_captured_count"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">gptimer_get_captured_count()</span></code></a></p></li>
<li><p><a class="reference internal" href="#_CPPv424gptimer_set_alarm_action16gptimer_handle_tPK22gptimer_alarm_config_t" title="gptimer_set_alarm_action"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">gptimer_set_alarm_action()</span></code></a></p></li>
</ul>
</p>
</section>
<section id="cache-safety">
<h3><a class="toc-backref" href="#id17" role="doc-backlink">Cache Safety</a><a class="headerlink" href="#cache-safety" title="Permalink to this heading"></a></h3>
<p>When the file system performs Flash read/write operations, the system temporarily disables the Cache function to avoid errors when loading instructions and data from Flash. This causes the GPTimer interrupt handler to be unresponsive during this period, preventing the user callback function from executing in time. If you want the interrupt handler to run normally when the Cache is disabled, you can enable the <a class="reference internal" href="../kconfig-reference.html#config-gptimer-isr-cache-safe"><span class="std std-ref">CONFIG_GPTIMER_ISR_CACHE_SAFE</span></a> option.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Note that when this option is enabled, all interrupt callback functions and their context data <strong>must be placed in internal storage</strong>. This is because the system cannot load data and instructions from Flash when the Cache is disabled.</p>
</div>
</section>
<section id="performance">
<h3><a class="toc-backref" href="#id18" role="doc-backlink">Performance</a><a class="headerlink" href="#performance" title="Permalink to this heading"></a></h3>
<p>To improve the real-time responsiveness of interrupt handling, the GPTimer driver provides the <a class="reference internal" href="../kconfig-reference.html#config-gptimer-isr-handler-in-iram"><span class="std std-ref">CONFIG_GPTIMER_ISR_HANDLER_IN_IRAM</span></a> option. Once enabled, the interrupt handler is placed in internal RAM, reducing delays caused by potential cache misses when loading instructions from Flash.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>However, the user callback function and its context data called by the interrupt handler may still reside in Flash. Cache misses are still possible, so users must manually place the callback function and data in internal RAM, for example by using <code class="xref c c-macro docutils literal notranslate"><span class="pre">IRAM_ATTR</span></code> and <code class="xref c c-macro docutils literal notranslate"><span class="pre">DRAM_ATTR</span></code>.</p>
</div>
<p>As mentioned above, the GPTimer driver allows some functions to be called in an interrupt context. By enabling the <a class="reference internal" href="../kconfig-reference.html#config-gptimer-ctrl-func-in-iram"><span class="std std-ref">CONFIG_GPTIMER_CTRL_FUNC_IN_IRAM</span></a> option, these functions can also be placed in IRAM, which helps avoid performance loss caused by cache misses and allows them to be used when the Cache is disabled.</p>
</section>
<section id="other-kconfig-options">
<h3><a class="toc-backref" href="#id19" role="doc-backlink">Other Kconfig Options</a><a class="headerlink" href="#other-kconfig-options" title="Permalink to this heading"></a></h3>
<ul class="simple">
<li><p>The <a class="reference internal" href="../kconfig-reference.html#config-gptimer-enable-debug-log"><span class="std std-ref">CONFIG_GPTIMER_ENABLE_DEBUG_LOG</span></a> option forces the GPTimer driver to enable all debug logs, regardless of the global log level settings. Enabling this option helps developers obtain more detailed log information during debugging, making it easier to locate and solve problems.</p></li>
</ul>
</section>
<section id="resource-consumption">
<h3><a class="toc-backref" href="#id20" role="doc-backlink">Resource Consumption</a><a class="headerlink" href="#resource-consumption" title="Permalink to this heading"></a></h3>
<p>Use the <a class="reference internal" href="../../api-guides/tools/idf-size.html"><span class="doc">IDF Size</span></a> tool to check the code and data consumption of the GPTimer driver. The following are the test conditions (using ESP32-C2 as an example):</p>
<ul class="simple">
<li><p>Compiler optimization level set to <code class="docutils literal notranslate"><span class="pre">-Os</span></code> to ensure minimal code size.</p></li>
<li><p>Default log level set to <code class="docutils literal notranslate"><span class="pre">ESP_LOG_INFO</span></code> to balance debug information and performance.</p></li>
<li><dl class="simple">
<dt>Disable the following driver optimization options:</dt><dd><ul>
<li><p><a class="reference internal" href="../kconfig-reference.html#config-gptimer-isr-handler-in-iram"><span class="std std-ref">CONFIG_GPTIMER_ISR_HANDLER_IN_IRAM</span></a> - Do not place the interrupt handler in IRAM.</p></li>
<li><p><a class="reference internal" href="../kconfig-reference.html#config-gptimer-ctrl-func-in-iram"><span class="std std-ref">CONFIG_GPTIMER_CTRL_FUNC_IN_IRAM</span></a> - Do not place control functions in IRAM.</p></li>
<li><p><a class="reference internal" href="../kconfig-reference.html#config-gptimer-isr-cache-safe"><span class="std std-ref">CONFIG_GPTIMER_ISR_CACHE_SAFE</span></a> - Do not enable Cache safety options.</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
<p><strong>Note that the following data are not exact values and are for reference only; they may differ on different chip models.</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Component Layer</p></th>
<th class="head"><p>Total Size</p></th>
<th class="head"><p>DIRAM</p></th>
<th class="head"><p>.bss</p></th>
<th class="head"><p>.data</p></th>
<th class="head"><p>.text</p></th>
<th class="head"><p>Flash Code</p></th>
<th class="head"><p>.text</p></th>
<th class="head"><p>Flash Data</p></th>
<th class="head"><p>.rodata</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>soc</p></td>
<td><p>8</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>8</p></td>
<td><p>8</p></td>
</tr>
<tr class="row-odd"><td><p>hal</p></td>
<td><p>206</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>206</p></td>
<td><p>206</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-even"><td><p>driver</p></td>
<td><p>4251</p></td>
<td><p>12</p></td>
<td><p>12</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>4046</p></td>
<td><p>4046</p></td>
<td><p>193</p></td>
<td><p>193</p></td>
</tr>
</tbody>
</table>
<p>Additionally, each GPTimer handle dynamically allocates about <code class="docutils literal notranslate"><span class="pre">100</span></code> bytes of memory from the heap. If the <code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">gptimer_config_t::flags::allow_pd</span></code> option is enabled, each timer will also consume approximately <code class="docutils literal notranslate"><span class="pre">30</span></code> extra bytes of memory during sleep to store the register context.</p>
</section>
</section>
<section id="application-examples">
<h2><a class="toc-backref" href="#id21" role="doc-backlink">Application Examples</a><a class="headerlink" href="#application-examples" title="Permalink to this heading"></a></h2>
<p><ul class="simple">
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/tree/758939ca/examples/peripherals/timer_group/gptimer">peripherals/timer_group/gptimer</a> demonstrates how to use the general-purpose timer APIs on ESP SOC chips to generate periodic alarm events and trigger different alarm actions.</p></li>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/tree/758939ca/examples/peripherals/timer_group/wiegand_interface">peripherals/timer_group/wiegand_interface</a> uses two timers (one in one-shot alarm mode and the other in periodic alarm mode) to trigger interrupts and change the GPIO output state in the alarm event callback function, simulating the output waveform of the Wiegand protocol.</p></li>
</ul>
</p>
</section>
<section id="api-reference">
<h2><a class="toc-backref" href="#id22" role="doc-backlink">API Reference</a><a class="headerlink" href="#api-reference" title="Permalink to this heading"></a></h2>
<section id="header-file">
<h3><a class="toc-backref" href="#id23" role="doc-backlink">Header File</a><a class="headerlink" href="#header-file" title="Permalink to this heading"></a></h3>
<ul>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/blob/758939ca/components/esp_driver_gptimer/include/driver/gptimer.h">components/esp_driver_gptimer/include/driver/gptimer.h</a></p></li>
<li><p>This header file can be included with:</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;driver/gptimer.h&quot;</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>This header file is a part of the API provided by the <code class="docutils literal notranslate"><span class="pre">esp_driver_gptimer</span></code> component. To declare that your component depends on <code class="docutils literal notranslate"><span class="pre">esp_driver_gptimer</span></code>, add the following to your CMakeLists.txt:</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>REQUIRES esp_driver_gptimer
</pre></div>
</div>
<p>or</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>PRIV_REQUIRES esp_driver_gptimer
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</section>
<section id="functions">
<h3><a class="toc-backref" href="#id24" role="doc-backlink">Functions</a><a class="headerlink" href="#functions" title="Permalink to this heading"></a></h3>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417gptimer_new_timerPK16gptimer_config_tP16gptimer_handle_t">
<span id="_CPPv317gptimer_new_timerPK16gptimer_config_tP16gptimer_handle_t"></span><span id="_CPPv217gptimer_new_timerPK16gptimer_config_tP16gptimer_handle_t"></span><span id="gptimer_new_timer__gptimer_config_tCP.gptimer_handle_tP"></span><span class="target" id="gptimer_8h_1a0ff72b8504c944a4db511e0c71e50922"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gptimer_new_timer</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv416gptimer_config_t" title="gptimer_config_t"><span class="n"><span class="pre">gptimer_config_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">config</span></span>, <a class="reference internal" href="#_CPPv416gptimer_handle_t" title="gptimer_handle_t"><span class="n"><span class="pre">gptimer_handle_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">ret_timer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417gptimer_new_timerPK16gptimer_config_tP16gptimer_handle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Create a new General Purpose Timer, and return the handle. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The newly created timer is put in the &quot;init&quot; state.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>config</strong> -- <strong>[in]</strong> GPTimer configuration </p></li>
<li><p><strong>ret_timer</strong> -- <strong>[out]</strong> Returned timer handle </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Create GPTimer successfully</p></li>
<li><p>ESP_ERR_INVALID_ARG: Create GPTimer failed because of invalid argument</p></li>
<li><p>ESP_ERR_NO_MEM: Create GPTimer failed because out of memory</p></li>
<li><p>ESP_ERR_NOT_FOUND: Create GPTimer failed because all hardware timers are used up and no more free one</p></li>
<li><p>ESP_FAIL: Create GPTimer failed because of other error </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417gptimer_del_timer16gptimer_handle_t">
<span id="_CPPv317gptimer_del_timer16gptimer_handle_t"></span><span id="_CPPv217gptimer_del_timer16gptimer_handle_t"></span><span id="gptimer_del_timer__gptimer_handle_t"></span><span class="target" id="gptimer_8h_1af72c98ee800ee39760b3cfea931aec2f"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gptimer_del_timer</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv416gptimer_handle_t" title="gptimer_handle_t"><span class="n"><span class="pre">gptimer_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">timer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417gptimer_del_timer16gptimer_handle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Delete the GPTimer handle. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A timer must be in the &quot;init&quot; state before it can be deleted.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>timer</strong> -- <strong>[in]</strong> Timer handle created by <code class="docutils literal notranslate"><span class="pre">gptimer_new_timer</span></code></p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Delete GPTimer successfully</p></li>
<li><p>ESP_ERR_INVALID_ARG: Delete GPTimer failed because of invalid argument</p></li>
<li><p>ESP_ERR_INVALID_STATE: Delete GPTimer failed because the timer is not in init state</p></li>
<li><p>ESP_FAIL: Delete GPTimer failed because of other error </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv421gptimer_set_raw_count16gptimer_handle_t8uint64_t">
<span id="_CPPv321gptimer_set_raw_count16gptimer_handle_t8uint64_t"></span><span id="_CPPv221gptimer_set_raw_count16gptimer_handle_t8uint64_t"></span><span id="gptimer_set_raw_count__gptimer_handle_t.uint64_t"></span><span class="target" id="gptimer_8h_1ac6e4ec0727e7badad85bfdc545ac89f1"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gptimer_set_raw_count</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv416gptimer_handle_t" title="gptimer_handle_t"><span class="n"><span class="pre">gptimer_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">timer</span></span>, <span class="n"><span class="pre">uint64_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">value</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv421gptimer_set_raw_count16gptimer_handle_t8uint64_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Set GPTimer raw count value. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When updating the raw count of an active timer, the timer will immediately start counting from the new value. </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is allowed to run within ISR context </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <code class="docutils literal notranslate"><span class="pre">CONFIG_GPTIMER_CTRL_FUNC_IN_IRAM</span></code> is enabled, this function will be placed in the IRAM by linker, makes it possible to execute even when the Flash Cache is disabled.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>timer</strong> -- <strong>[in]</strong> Timer handle created by <code class="docutils literal notranslate"><span class="pre">gptimer_new_timer</span></code></p></li>
<li><p><strong>value</strong> -- <strong>[in]</strong> Count value to be set </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Set GPTimer raw count value successfully</p></li>
<li><p>ESP_ERR_INVALID_ARG: Set GPTimer raw count value failed because of invalid argument</p></li>
<li><p>ESP_FAIL: Set GPTimer raw count value failed because of other error </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv421gptimer_get_raw_count16gptimer_handle_tP8uint64_t">
<span id="_CPPv321gptimer_get_raw_count16gptimer_handle_tP8uint64_t"></span><span id="_CPPv221gptimer_get_raw_count16gptimer_handle_tP8uint64_t"></span><span id="gptimer_get_raw_count__gptimer_handle_t.uint64_tP"></span><span class="target" id="gptimer_8h_1a9918318aa20cf9347988c9584e61a00a"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gptimer_get_raw_count</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv416gptimer_handle_t" title="gptimer_handle_t"><span class="n"><span class="pre">gptimer_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">timer</span></span>, <span class="n"><span class="pre">uint64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">value</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv421gptimer_get_raw_count16gptimer_handle_tP8uint64_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Get GPTimer raw count value. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function will trigger a software capture event and then return the captured count value. </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>With the raw count value and the resolution returned from <code class="docutils literal notranslate"><span class="pre">gptimer_get_resolution</span></code>, you can convert the count value into seconds. </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is allowed to run within ISR context </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <code class="docutils literal notranslate"><span class="pre">CONFIG_GPTIMER_CTRL_FUNC_IN_IRAM</span></code> is enabled, this function will be placed in the IRAM by linker, makes it possible to execute even when the Flash Cache is disabled.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>timer</strong> -- <strong>[in]</strong> Timer handle created by <code class="docutils literal notranslate"><span class="pre">gptimer_new_timer</span></code></p></li>
<li><p><strong>value</strong> -- <strong>[out]</strong> Returned GPTimer count value </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Get GPTimer raw count value successfully</p></li>
<li><p>ESP_ERR_INVALID_ARG: Get GPTimer raw count value failed because of invalid argument</p></li>
<li><p>ESP_FAIL: Get GPTimer raw count value failed because of other error </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv422gptimer_get_resolution16gptimer_handle_tP8uint32_t">
<span id="_CPPv322gptimer_get_resolution16gptimer_handle_tP8uint32_t"></span><span id="_CPPv222gptimer_get_resolution16gptimer_handle_tP8uint32_t"></span><span id="gptimer_get_resolution__gptimer_handle_t.uint32_tP"></span><span class="target" id="gptimer_8h_1abc88ca9d6b8d9e8799fc9934a6cd02a0"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gptimer_get_resolution</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv416gptimer_handle_t" title="gptimer_handle_t"><span class="n"><span class="pre">gptimer_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">timer</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">out_resolution</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422gptimer_get_resolution16gptimer_handle_tP8uint32_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Return the real resolution of the timer. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>usually the timer resolution is same as what you configured in the <code class="docutils literal notranslate"><a class="reference internal" href="#structgptimer__config__t_1ab45737a731f41afe4faa54f02b6e0a0a"><span class="std std-ref"><span class="pre">gptimer_config_t::resolution_hz</span></span></a></code>, but some unstable clock source (e.g. RC_FAST) will do a calibration, the real resolution can be different from the configured one.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>timer</strong> -- <strong>[in]</strong> Timer handle created by <code class="docutils literal notranslate"><span class="pre">gptimer_new_timer</span></code></p></li>
<li><p><strong>out_resolution</strong> -- <strong>[out]</strong> Returned timer resolution, in Hz </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Get GPTimer resolution successfully</p></li>
<li><p>ESP_ERR_INVALID_ARG: Get GPTimer resolution failed because of invalid argument</p></li>
<li><p>ESP_FAIL: Get GPTimer resolution failed because of other error </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv426gptimer_get_captured_count16gptimer_handle_tP8uint64_t">
<span id="_CPPv326gptimer_get_captured_count16gptimer_handle_tP8uint64_t"></span><span id="_CPPv226gptimer_get_captured_count16gptimer_handle_tP8uint64_t"></span><span id="gptimer_get_captured_count__gptimer_handle_t.uint64_tP"></span><span class="target" id="gptimer_8h_1aefef03ab3c05d6e1b76200fa99b4b474"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gptimer_get_captured_count</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv416gptimer_handle_t" title="gptimer_handle_t"><span class="n"><span class="pre">gptimer_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">timer</span></span>, <span class="n"><span class="pre">uint64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">value</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv426gptimer_get_captured_count16gptimer_handle_tP8uint64_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Get GPTimer captured count value. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Different from <code class="docutils literal notranslate"><span class="pre">gptimer_get_raw_count</span></code>, this function won't trigger a software capture event. It just returns the last captured count value. It's especially useful when the capture has already been triggered by an external event and you want to read the captured value. </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is allowed to run within ISR context </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <code class="docutils literal notranslate"><span class="pre">CONFIG_GPTIMER_CTRL_FUNC_IN_IRAM</span></code> is enabled, this function will be placed in the IRAM by linker, makes it possible to execute even when the Flash Cache is disabled.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>timer</strong> -- <strong>[in]</strong> Timer handle created by <code class="docutils literal notranslate"><span class="pre">gptimer_new_timer</span></code></p></li>
<li><p><strong>value</strong> -- <strong>[out]</strong> Returned captured count value </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Get GPTimer captured count value successfully</p></li>
<li><p>ESP_ERR_INVALID_ARG: Get GPTimer captured count value failed because of invalid argument</p></li>
<li><p>ESP_FAIL: Get GPTimer captured count value failed because of other error </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv432gptimer_register_event_callbacks16gptimer_handle_tPK25gptimer_event_callbacks_tPv">
<span id="_CPPv332gptimer_register_event_callbacks16gptimer_handle_tPK25gptimer_event_callbacks_tPv"></span><span id="_CPPv232gptimer_register_event_callbacks16gptimer_handle_tPK25gptimer_event_callbacks_tPv"></span><span id="gptimer_register_event_callbacks__gptimer_handle_t.gptimer_event_callbacks_tCP.voidP"></span><span class="target" id="gptimer_8h_1ace2479ceae75e79c2730d8ef0552642d"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gptimer_register_event_callbacks</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv416gptimer_handle_t" title="gptimer_handle_t"><span class="n"><span class="pre">gptimer_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">timer</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv425gptimer_event_callbacks_t" title="gptimer_event_callbacks_t"><span class="n"><span class="pre">gptimer_event_callbacks_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">cbs</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">user_data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv432gptimer_register_event_callbacks16gptimer_handle_tPK25gptimer_event_callbacks_tPv" title="Permalink to this definition"></a><br /></dt>
<dd><p>Set callbacks for GPTimer. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>User registered callbacks are expected to be runnable within ISR context </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The first call to this function needs to be before the call to <code class="docutils literal notranslate"><span class="pre">gptimer_enable</span></code></p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>User can deregister a previously registered callback by calling this function and setting the callback member in the <code class="docutils literal notranslate"><span class="pre">cbs</span></code> structure to NULL.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>timer</strong> -- <strong>[in]</strong> Timer handle created by <code class="docutils literal notranslate"><span class="pre">gptimer_new_timer</span></code></p></li>
<li><p><strong>cbs</strong> -- <strong>[in]</strong> Group of callback functions </p></li>
<li><p><strong>user_data</strong> -- <strong>[in]</strong> User data, which will be passed to callback functions directly </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Set event callbacks successfully</p></li>
<li><p>ESP_ERR_INVALID_ARG: Set event callbacks failed because of invalid argument</p></li>
<li><p>ESP_ERR_INVALID_STATE: Set event callbacks failed because the timer is not in init state</p></li>
<li><p>ESP_FAIL: Set event callbacks failed because of other error </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv424gptimer_set_alarm_action16gptimer_handle_tPK22gptimer_alarm_config_t">
<span id="_CPPv324gptimer_set_alarm_action16gptimer_handle_tPK22gptimer_alarm_config_t"></span><span id="_CPPv224gptimer_set_alarm_action16gptimer_handle_tPK22gptimer_alarm_config_t"></span><span id="gptimer_set_alarm_action__gptimer_handle_t.gptimer_alarm_config_tCP"></span><span class="target" id="gptimer_8h_1a33aa960104b3358d5ae87e320770c8fd"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gptimer_set_alarm_action</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv416gptimer_handle_t" title="gptimer_handle_t"><span class="n"><span class="pre">gptimer_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">timer</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv422gptimer_alarm_config_t" title="gptimer_alarm_config_t"><span class="n"><span class="pre">gptimer_alarm_config_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">config</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424gptimer_set_alarm_action16gptimer_handle_tPK22gptimer_alarm_config_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Set alarm event actions for GPTimer. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is allowed to run within ISR context, so you can update new alarm action immediately in any ISR callback. </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <code class="docutils literal notranslate"><span class="pre">CONFIG_GPTIMER_CTRL_FUNC_IN_IRAM</span></code> is enabled, this function will be placed in the IRAM by linker, makes it possible to execute even when the Flash Cache is disabled. In this case, please also ensure the <code class="docutils literal notranslate"><a class="reference internal" href="#structgptimer__alarm__config__t"><span class="std std-ref"><span class="pre">gptimer_alarm_config_t</span></span></a></code> instance is placed in the static data section instead of in the read-only data section. e.g.: <code class="docutils literal notranslate"><span class="pre">static</span> <a class="reference internal" href="#structgptimer__alarm__config__t"><span class="std std-ref"><span class="pre">gptimer_alarm_config_t</span></span></a> <span class="pre">alarm_config</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">};</span></code></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>timer</strong> -- <strong>[in]</strong> Timer handle created by <code class="docutils literal notranslate"><span class="pre">gptimer_new_timer</span></code></p></li>
<li><p><strong>config</strong> -- <strong>[in]</strong> Alarm configuration, especially, set config to NULL means disabling the alarm function </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Set alarm action for GPTimer successfully</p></li>
<li><p>ESP_ERR_INVALID_ARG: Set alarm action for GPTimer failed because of invalid argument</p></li>
<li><p>ESP_FAIL: Set alarm action for GPTimer failed because of other error </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv414gptimer_enable16gptimer_handle_t">
<span id="_CPPv314gptimer_enable16gptimer_handle_t"></span><span id="_CPPv214gptimer_enable16gptimer_handle_t"></span><span id="gptimer_enable__gptimer_handle_t"></span><span class="target" id="gptimer_8h_1a7433ec78be15278588d5ce83bc446cb9"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gptimer_enable</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv416gptimer_handle_t" title="gptimer_handle_t"><span class="n"><span class="pre">gptimer_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">timer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414gptimer_enable16gptimer_handle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Enable GPTimer. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function will transit the timer state from &quot;init&quot; to &quot;enable&quot;. </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function will enable the interrupt service, if it's lazy installed in <code class="docutils literal notranslate"><span class="pre">gptimer_register_event_callbacks</span></code>. </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function will acquire a PM lock, if a specific source clock (e.g. APB) is selected in the <code class="docutils literal notranslate"><a class="reference internal" href="#structgptimer__config__t"><span class="std std-ref"><span class="pre">gptimer_config_t</span></span></a></code>, while <code class="docutils literal notranslate"><span class="pre">CONFIG_PM_ENABLE</span></code> is enabled. </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Enable a timer doesn't mean to start it. See also <code class="docutils literal notranslate"><span class="pre">gptimer_start</span></code> for how to make the timer start counting.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>timer</strong> -- <strong>[in]</strong> Timer handle created by <code class="docutils literal notranslate"><span class="pre">gptimer_new_timer</span></code></p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Enable GPTimer successfully</p></li>
<li><p>ESP_ERR_INVALID_ARG: Enable GPTimer failed because of invalid argument</p></li>
<li><p>ESP_ERR_INVALID_STATE: Enable GPTimer failed because the timer is already enabled</p></li>
<li><p>ESP_FAIL: Enable GPTimer failed because of other error </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv415gptimer_disable16gptimer_handle_t">
<span id="_CPPv315gptimer_disable16gptimer_handle_t"></span><span id="_CPPv215gptimer_disable16gptimer_handle_t"></span><span id="gptimer_disable__gptimer_handle_t"></span><span class="target" id="gptimer_8h_1aed5b16068e124dc5f349c8df43af0cae"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gptimer_disable</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv416gptimer_handle_t" title="gptimer_handle_t"><span class="n"><span class="pre">gptimer_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">timer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415gptimer_disable16gptimer_handle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Disable GPTimer. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function will transit the timer state from &quot;enable&quot; to &quot;init&quot;. </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function will disable the interrupt service if it's installed. </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function will release the PM lock if it's acquired in the <code class="docutils literal notranslate"><span class="pre">gptimer_enable</span></code>. </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Disable a timer doesn't mean to stop it. See also <code class="docutils literal notranslate"><span class="pre">gptimer_stop</span></code> for how to make the timer stop counting.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>timer</strong> -- <strong>[in]</strong> Timer handle created by <code class="docutils literal notranslate"><span class="pre">gptimer_new_timer</span></code></p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Disable GPTimer successfully</p></li>
<li><p>ESP_ERR_INVALID_ARG: Disable GPTimer failed because of invalid argument</p></li>
<li><p>ESP_ERR_INVALID_STATE: Disable GPTimer failed because the timer is not enabled yet</p></li>
<li><p>ESP_FAIL: Disable GPTimer failed because of other error </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv413gptimer_start16gptimer_handle_t">
<span id="_CPPv313gptimer_start16gptimer_handle_t"></span><span id="_CPPv213gptimer_start16gptimer_handle_t"></span><span id="gptimer_start__gptimer_handle_t"></span><span class="target" id="gptimer_8h_1a1f37cb270dd5ca60f192e7fd21105c66"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gptimer_start</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv416gptimer_handle_t" title="gptimer_handle_t"><span class="n"><span class="pre">gptimer_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">timer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413gptimer_start16gptimer_handle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Start GPTimer (internal counter starts counting) </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function will transit the timer state from &quot;enable&quot; to &quot;run&quot;. </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is allowed to run within ISR context </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <code class="docutils literal notranslate"><span class="pre">CONFIG_GPTIMER_CTRL_FUNC_IN_IRAM</span></code> is enabled, this function will be placed in the IRAM by linker, makes it possible to execute even when the Flash Cache is disabled.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>timer</strong> -- <strong>[in]</strong> Timer handle created by <code class="docutils literal notranslate"><span class="pre">gptimer_new_timer</span></code></p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Start GPTimer successfully</p></li>
<li><p>ESP_ERR_INVALID_ARG: Start GPTimer failed because of invalid argument</p></li>
<li><p>ESP_ERR_INVALID_STATE: Start GPTimer failed because the timer is not enabled or is already in running</p></li>
<li><p>ESP_FAIL: Start GPTimer failed because of other error </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv412gptimer_stop16gptimer_handle_t">
<span id="_CPPv312gptimer_stop16gptimer_handle_t"></span><span id="_CPPv212gptimer_stop16gptimer_handle_t"></span><span id="gptimer_stop__gptimer_handle_t"></span><span class="target" id="gptimer_8h_1a98ee619e279f647baea168716e7da537"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t"><span class="n"><span class="pre">esp_err_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gptimer_stop</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv416gptimer_handle_t" title="gptimer_handle_t"><span class="n"><span class="pre">gptimer_handle_t</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">timer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412gptimer_stop16gptimer_handle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Stop GPTimer (internal counter stops counting) </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function will transit the timer state from &quot;run&quot; to &quot;enable&quot;. </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is allowed to run within ISR context </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <code class="docutils literal notranslate"><span class="pre">CONFIG_GPTIMER_CTRL_FUNC_IN_IRAM</span></code> is enabled, this function will be placed in the IRAM by linker, makes it possible to execute even when the Flash Cache is disabled.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>timer</strong> -- <strong>[in]</strong> Timer handle created by <code class="docutils literal notranslate"><span class="pre">gptimer_new_timer</span></code></p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>ESP_OK: Stop GPTimer successfully</p></li>
<li><p>ESP_ERR_INVALID_ARG: Stop GPTimer failed because of invalid argument</p></li>
<li><p>ESP_ERR_INVALID_STATE: Stop GPTimer failed because the timer is not in running.</p></li>
<li><p>ESP_FAIL: Stop GPTimer failed because of other error </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="structures">
<h3><a class="toc-backref" href="#id25" role="doc-backlink">Structures</a><a class="headerlink" href="#structures" title="Permalink to this heading"></a></h3>
<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv416gptimer_config_t">
<span id="_CPPv316gptimer_config_t"></span><span id="_CPPv216gptimer_config_t"></span><span id="gptimer_config_t"></span><span class="target" id="structgptimer__config__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gptimer_config_t</span></span></span><a class="headerlink" href="#_CPPv416gptimer_config_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>General Purpose Timer configuration. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N16gptimer_config_t7clk_srcE">
<span id="_CPPv3N16gptimer_config_t7clk_srcE"></span><span id="_CPPv2N16gptimer_config_t7clk_srcE"></span><span id="gptimer_config_t::clk_src__gptimer_clock_source_t"></span><span class="target" id="structgptimer__config__t_1a489540c3cfe8cfa9ce78f378d99697a4"></span><a class="reference internal" href="#_CPPv422gptimer_clock_source_t" title="gptimer_clock_source_t"><span class="n"><span class="pre">gptimer_clock_source_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clk_src</span></span></span><a class="headerlink" href="#_CPPv4N16gptimer_config_t7clk_srcE" title="Permalink to this definition"></a><br /></dt>
<dd><p>GPTimer clock source </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N16gptimer_config_t9directionE">
<span id="_CPPv3N16gptimer_config_t9directionE"></span><span id="_CPPv2N16gptimer_config_t9directionE"></span><span id="gptimer_config_t::direction__gptimer_count_direction_t"></span><span class="target" id="structgptimer__config__t_1ac0233e35d8512519d14330af63eb8ca5"></span><a class="reference internal" href="#_CPPv425gptimer_count_direction_t" title="gptimer_count_direction_t"><span class="n"><span class="pre">gptimer_count_direction_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">direction</span></span></span><a class="headerlink" href="#_CPPv4N16gptimer_config_t9directionE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Count direction </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N16gptimer_config_t13resolution_hzE">
<span id="_CPPv3N16gptimer_config_t13resolution_hzE"></span><span id="_CPPv2N16gptimer_config_t13resolution_hzE"></span><span id="gptimer_config_t::resolution_hz__uint32_t"></span><span class="target" id="structgptimer__config__t_1ab45737a731f41afe4faa54f02b6e0a0a"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">resolution_hz</span></span></span><a class="headerlink" href="#_CPPv4N16gptimer_config_t13resolution_hzE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Counter resolution (working frequency) in Hz, hence, the step size of each count tick equals to (1 / resolution_hz) seconds </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N16gptimer_config_t13intr_priorityE">
<span id="_CPPv3N16gptimer_config_t13intr_priorityE"></span><span id="_CPPv2N16gptimer_config_t13intr_priorityE"></span><span id="gptimer_config_t::intr_priority__i"></span><span class="target" id="structgptimer__config__t_1aac05c12ef33dbd5280309f63509d5819"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">intr_priority</span></span></span><a class="headerlink" href="#_CPPv4N16gptimer_config_t13intr_priorityE" title="Permalink to this definition"></a><br /></dt>
<dd><p>GPTimer interrupt priority, if set to 0, the driver will try to allocate an interrupt with a relative low priority (1,2,3) </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N16gptimer_config_t11intr_sharedE">
<span id="_CPPv3N16gptimer_config_t11intr_sharedE"></span><span id="_CPPv2N16gptimer_config_t11intr_sharedE"></span><span id="gptimer_config_t::intr_shared__uint32_t"></span><span class="target" id="structgptimer__config__t_1aaf29a3b38a31bcf3a36176d8a8862eda"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">intr_shared</span></span></span><a class="headerlink" href="#_CPPv4N16gptimer_config_t11intr_sharedE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Set true, the timer interrupt number can be shared with other peripherals </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N16gptimer_config_t8allow_pdE">
<span id="_CPPv3N16gptimer_config_t8allow_pdE"></span><span id="_CPPv2N16gptimer_config_t8allow_pdE"></span><span id="gptimer_config_t::allow_pd__uint32_t"></span><span class="target" id="structgptimer__config__t_1a0f6094bc7901ada43860f8acda13962a"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">allow_pd</span></span></span><a class="headerlink" href="#_CPPv4N16gptimer_config_t8allow_pdE" title="Permalink to this definition"></a><br /></dt>
<dd><p>If set, driver allows the power domain to be powered off when system enters sleep mode. This can save power, but at the expense of more RAM being consumed to save register context. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N16gptimer_config_t5flagsE">
<span id="_CPPv3N16gptimer_config_t5flagsE"></span><span id="_CPPv2N16gptimer_config_t5flagsE"></span><span id="gptimer_config_t::flags__gptimer_config_t"></span><span class="target" id="structgptimer__config__t_1a8b37c9fc530c6b373f86b11c12c04d39"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv416gptimer_config_t" title="gptimer_config_t"><span class="n"><span class="pre">gptimer_config_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">flags</span></span></span><a class="headerlink" href="#_CPPv4N16gptimer_config_t5flagsE" title="Permalink to this definition"></a><br /></dt>
<dd><p>GPTimer config flags </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv425gptimer_event_callbacks_t">
<span id="_CPPv325gptimer_event_callbacks_t"></span><span id="_CPPv225gptimer_event_callbacks_t"></span><span id="gptimer_event_callbacks_t"></span><span class="target" id="structgptimer__event__callbacks__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gptimer_event_callbacks_t</span></span></span><a class="headerlink" href="#_CPPv425gptimer_event_callbacks_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Group of supported GPTimer callbacks. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The callbacks are all running under ISR environment </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When CONFIG_GPTIMER_ISR_CACHE_SAFE is enabled, the callback itself and functions called by it should be placed in IRAM. </p>
</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N25gptimer_event_callbacks_t8on_alarmE">
<span id="_CPPv3N25gptimer_event_callbacks_t8on_alarmE"></span><span id="_CPPv2N25gptimer_event_callbacks_t8on_alarmE"></span><span id="gptimer_event_callbacks_t::on_alarm__gptimer_alarm_cb_t"></span><span class="target" id="structgptimer__event__callbacks__t_1a1968544b0fb6cd281e0739e4d9bcf1d2"></span><a class="reference internal" href="#_CPPv418gptimer_alarm_cb_t" title="gptimer_alarm_cb_t"><span class="n"><span class="pre">gptimer_alarm_cb_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">on_alarm</span></span></span><a class="headerlink" href="#_CPPv4N25gptimer_event_callbacks_t8on_alarmE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Timer alarm callback </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv422gptimer_alarm_config_t">
<span id="_CPPv322gptimer_alarm_config_t"></span><span id="_CPPv222gptimer_alarm_config_t"></span><span id="gptimer_alarm_config_t"></span><span class="target" id="structgptimer__alarm__config__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gptimer_alarm_config_t</span></span></span><a class="headerlink" href="#_CPPv422gptimer_alarm_config_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>General Purpose Timer alarm configuration. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N22gptimer_alarm_config_t11alarm_countE">
<span id="_CPPv3N22gptimer_alarm_config_t11alarm_countE"></span><span id="_CPPv2N22gptimer_alarm_config_t11alarm_countE"></span><span id="gptimer_alarm_config_t::alarm_count__uint64_t"></span><span class="target" id="structgptimer__alarm__config__t_1af68accaffe6b5cb77d37c2d83cc35587"></span><span class="n"><span class="pre">uint64_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">alarm_count</span></span></span><a class="headerlink" href="#_CPPv4N22gptimer_alarm_config_t11alarm_countE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Alarm target count value </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N22gptimer_alarm_config_t12reload_countE">
<span id="_CPPv3N22gptimer_alarm_config_t12reload_countE"></span><span id="_CPPv2N22gptimer_alarm_config_t12reload_countE"></span><span id="gptimer_alarm_config_t::reload_count__uint64_t"></span><span class="target" id="structgptimer__alarm__config__t_1acfd532d79685069019f06b7c7ca5084b"></span><span class="n"><span class="pre">uint64_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">reload_count</span></span></span><a class="headerlink" href="#_CPPv4N22gptimer_alarm_config_t12reload_countE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Alarm reload count value, effect only when <code class="docutils literal notranslate"><span class="pre">auto_reload_on_alarm</span></code> is set to true </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N22gptimer_alarm_config_t20auto_reload_on_alarmE">
<span id="_CPPv3N22gptimer_alarm_config_t20auto_reload_on_alarmE"></span><span id="_CPPv2N22gptimer_alarm_config_t20auto_reload_on_alarmE"></span><span id="gptimer_alarm_config_t::auto_reload_on_alarm__uint32_t"></span><span class="target" id="structgptimer__alarm__config__t_1a46bd9d255c70f5c7ef47fe994a9bcf01"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">auto_reload_on_alarm</span></span></span><a class="headerlink" href="#_CPPv4N22gptimer_alarm_config_t20auto_reload_on_alarmE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Reload the count value by hardware, immediately at the alarm event </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N22gptimer_alarm_config_t5flagsE">
<span id="_CPPv3N22gptimer_alarm_config_t5flagsE"></span><span id="_CPPv2N22gptimer_alarm_config_t5flagsE"></span><span id="gptimer_alarm_config_t::flags__gptimer_alarm_config_t"></span><span class="target" id="structgptimer__alarm__config__t_1ad7ef90f0dfc489772d8d6bb295088dba"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv422gptimer_alarm_config_t" title="gptimer_alarm_config_t"><span class="n"><span class="pre">gptimer_alarm_config_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">flags</span></span></span><a class="headerlink" href="#_CPPv4N22gptimer_alarm_config_t5flagsE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Alarm config flags </p>
</dd></dl>

</div>
</dd></dl>

</section>
<section id="id1">
<h3><a class="toc-backref" href="#id26" role="doc-backlink">Header File</a><a class="headerlink" href="#id1" title="Permalink to this heading"></a></h3>
<ul>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/blob/758939ca/components/esp_driver_gptimer/include/driver/gptimer_types.h">components/esp_driver_gptimer/include/driver/gptimer_types.h</a></p></li>
<li><p>This header file can be included with:</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;driver/gptimer_types.h&quot;</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>This header file is a part of the API provided by the <code class="docutils literal notranslate"><span class="pre">esp_driver_gptimer</span></code> component. To declare that your component depends on <code class="docutils literal notranslate"><span class="pre">esp_driver_gptimer</span></code>, add the following to your CMakeLists.txt:</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>REQUIRES esp_driver_gptimer
</pre></div>
</div>
<p>or</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>PRIV_REQUIRES esp_driver_gptimer
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</section>
<section id="id2">
<h3><a class="toc-backref" href="#id27" role="doc-backlink">Structures</a><a class="headerlink" href="#id2" title="Permalink to this heading"></a></h3>
<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv426gptimer_alarm_event_data_t">
<span id="_CPPv326gptimer_alarm_event_data_t"></span><span id="_CPPv226gptimer_alarm_event_data_t"></span><span id="gptimer_alarm_event_data_t"></span><span class="target" id="structgptimer__alarm__event__data__t"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gptimer_alarm_event_data_t</span></span></span><a class="headerlink" href="#_CPPv426gptimer_alarm_event_data_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>GPTimer alarm event data. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N26gptimer_alarm_event_data_t11count_valueE">
<span id="_CPPv3N26gptimer_alarm_event_data_t11count_valueE"></span><span id="_CPPv2N26gptimer_alarm_event_data_t11count_valueE"></span><span id="gptimer_alarm_event_data_t::count_value__uint64_t"></span><span class="target" id="structgptimer__alarm__event__data__t_1afbd042aa4729bf41e138f62feffa75f8"></span><span class="n"><span class="pre">uint64_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">count_value</span></span></span><a class="headerlink" href="#_CPPv4N26gptimer_alarm_event_data_t11count_valueE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Current count value </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N26gptimer_alarm_event_data_t11alarm_valueE">
<span id="_CPPv3N26gptimer_alarm_event_data_t11alarm_valueE"></span><span id="_CPPv2N26gptimer_alarm_event_data_t11alarm_valueE"></span><span id="gptimer_alarm_event_data_t::alarm_value__uint64_t"></span><span class="target" id="structgptimer__alarm__event__data__t_1abd2dd0e784b84ac7469617f1dd9ddc75"></span><span class="n"><span class="pre">uint64_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">alarm_value</span></span></span><a class="headerlink" href="#_CPPv4N26gptimer_alarm_event_data_t11alarm_valueE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Current alarm value </p>
</dd></dl>

</div>
</dd></dl>

</section>
<section id="type-definitions">
<h3><a class="toc-backref" href="#id28" role="doc-backlink">Type Definitions</a><a class="headerlink" href="#type-definitions" title="Permalink to this heading"></a></h3>
<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv416gptimer_handle_t">
<span id="_CPPv316gptimer_handle_t"></span><span id="_CPPv216gptimer_handle_t"></span><span id="gptimer_handle_t"></span><span class="target" id="gptimer__types_8h_1ae84104d2b5894010bdb6e87cb1be5331"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">gptimer_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gptimer_handle_t</span></span></span><a class="headerlink" href="#_CPPv416gptimer_handle_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Type of General Purpose Timer handle. </p>
</dd></dl>

<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv418gptimer_alarm_cb_t">
<span id="_CPPv318gptimer_alarm_cb_t"></span><span id="_CPPv218gptimer_alarm_cb_t"></span><span id="gptimer_alarm_cb_t"></span><span class="target" id="gptimer__types_8h_1a0d2f3e486e80de82bc76a624ab443a86"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gptimer_alarm_cb_t</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><a class="reference internal" href="#_CPPv416gptimer_handle_t" title="gptimer_handle_t"><span class="n"><span class="pre">gptimer_handle_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">timer</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv426gptimer_alarm_event_data_t" title="gptimer_alarm_event_data_t"><span class="n"><span class="pre">gptimer_alarm_event_data_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">edata</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">user_ctx</span></span><span class="p"><span class="pre">)</span></span><a class="headerlink" href="#_CPPv418gptimer_alarm_cb_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>Timer alarm callback prototype. </p>
<dl class="field-list simple">
<dt class="field-odd">Param timer<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>[in]</strong> Timer handle created by <code class="docutils literal notranslate"><span class="pre">gptimer_new_timer</span></code></p>
</dd>
<dt class="field-even">Param edata<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>[in]</strong> Alarm event data, fed by driver </p>
</dd>
<dt class="field-odd">Param user_ctx<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>[in]</strong> User data, passed from <code class="docutils literal notranslate"><span class="pre">gptimer_register_event_callbacks</span></code></p>
</dd>
<dt class="field-even">Return<span class="colon">:</span></dt>
<dd class="field-even"><p>Whether a high priority task has been waken up by this function </p>
</dd>
</dl>
</dd></dl>

</section>
<section id="id3">
<h3><a class="toc-backref" href="#id29" role="doc-backlink">Header File</a><a class="headerlink" href="#id3" title="Permalink to this heading"></a></h3>
<ul>
<li><p><a class="reference external" href="https://github.com/espressif/esp-idf/blob/758939ca/components/hal/include/hal/timer_types.h">components/hal/include/hal/timer_types.h</a></p></li>
<li><p>This header file can be included with:</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;hal/timer_types.h&quot;</span>
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</section>
<section id="id4">
<h3><a class="toc-backref" href="#id30" role="doc-backlink">Type Definitions</a><a class="headerlink" href="#id4" title="Permalink to this heading"></a></h3>
<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv422gptimer_clock_source_t">
<span id="_CPPv322gptimer_clock_source_t"></span><span id="_CPPv222gptimer_clock_source_t"></span><span id="gptimer_clock_source_t"></span><span class="target" id="timer__types_8h_1abd7f252ae4b2c7890f7db59aa7e10da7"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><a class="reference internal" href="clk_tree.html#_CPPv428soc_periph_gptimer_clk_src_t" title="soc_periph_gptimer_clk_src_t"><span class="n"><span class="pre">soc_periph_gptimer_clk_src_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gptimer_clock_source_t</span></span></span><a class="headerlink" href="#_CPPv422gptimer_clock_source_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>GPTimer clock source. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>User should select the clock source based on the power and resolution requirement </p>
</div>
</dd></dl>

</section>
<section id="enumerations">
<h3><a class="toc-backref" href="#id31" role="doc-backlink">Enumerations</a><a class="headerlink" href="#enumerations" title="Permalink to this heading"></a></h3>
<dl class="cpp enum">
<dt class="sig sig-object cpp" id="_CPPv425gptimer_count_direction_t">
<span id="_CPPv325gptimer_count_direction_t"></span><span id="_CPPv225gptimer_count_direction_t"></span><span class="target" id="timer__types_8h_1aaece2e8ea5450c2066f6e2fab59265b7"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gptimer_count_direction_t</span></span></span><a class="headerlink" href="#_CPPv425gptimer_count_direction_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>GPTimer count direction. </p>
<p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N25gptimer_count_direction_t18GPTIMER_COUNT_DOWNE">
<span id="_CPPv3N25gptimer_count_direction_t18GPTIMER_COUNT_DOWNE"></span><span id="_CPPv2N25gptimer_count_direction_t18GPTIMER_COUNT_DOWNE"></span><span class="target" id="timer__types_8h_1aaece2e8ea5450c2066f6e2fab59265b7a42634b1683a307e62317e9340f191682"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">GPTIMER_COUNT_DOWN</span></span></span><a class="headerlink" href="#_CPPv4N25gptimer_count_direction_t18GPTIMER_COUNT_DOWNE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Decrease count value </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N25gptimer_count_direction_t16GPTIMER_COUNT_UPE">
<span id="_CPPv3N25gptimer_count_direction_t16GPTIMER_COUNT_UPE"></span><span id="_CPPv2N25gptimer_count_direction_t16GPTIMER_COUNT_UPE"></span><span class="target" id="timer__types_8h_1aaece2e8ea5450c2066f6e2fab59265b7a1496bf43eda840982e24ec64525f0637"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">GPTIMER_COUNT_UP</span></span></span><a class="headerlink" href="#_CPPv4N25gptimer_count_direction_t16GPTIMER_COUNT_UPE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Increase count value </p>
</dd></dl>

</dd></dl>

</section>
</section>
</section>

    <script type="text/javascript">
        function init() {
            WaveDrom.ProcessAll();
        }
        window.onload = init;
    </script>

           </div>
             <div class="articleComments">

<style>
    .expand-feedback-content {
        display: none;
    }
    .click-like-or-dislike {
        background-color: #d3d3d3;
        pointer-events: none;
    }
</style>

<script>
    function submitFeedbackForm(user_likes_document) {
        // Send to GA4 the user reaction
        gtag('event', 'user_reaction', {
            'user_likes_document': user_likes_document
        });

        if (user_likes_document === 1) {
            document.querySelector('.like-btn').classList.add('click-like-or-dislike');
            document.getElementById("expandContentLike").style.display = 'block';
        } else {
            document.querySelector('.dislike-btn').classList.add('click-like-or-dislike');
            document.getElementById("expandContent").style.display = 'block';
        }

        document.querySelector('.like-btn').style.pointerEvents = 'none';
        document.querySelector('.dislike-btn').style.pointerEvents = 'none';
    }
</script>

<hr>

<p style="text-align:center"><strong>Was this page helpful?</strong></p>
<p style="text-align:center">
    <button class="like-btn" onclick="submitFeedbackForm(1)">
        <svg aria-hidden="true" focusable="false" class="color-fg-muted" viewBox="0 0 16 16" width="16" height="16" fill="currentColor" style="display:inline-block;user-select:none;vertical-align:text-bottom;overflow:visible">
            <path d="M8.834.066c.763.087 1.5.295 2.01.884.505.581.656 1.378.656 2.3 0 .467-.087 1.119-.157 1.637L11.328 5h1.422c.603 0 1.174.085 1.668.333.508.254.911.679 1.137 1.2.453.998.438 2.447.188 4.316l-.04.306c-.105.79-.195 1.473-.313 2.033-.131.63-.315 1.209-.668 1.672C13.97 15.847 12.706 16 11 16c-1.848 0-3.234-.333-4.388-.653-.165-.045-.323-.09-.475-.133-.658-.186-1.2-.34-1.725-.415A1.75 1.75 0 0 1 2.75 16h-1A1.75 1.75 0 0 1 0 14.25v-7.5C0 5.784.784 5 1.75 5h1a1.75 1.75 0 0 1 1.514.872c.258-.105.59-.268.918-.508C5.853 4.874 6.5 4.079 6.5 2.75v-.5c0-1.202.994-2.337 2.334-2.184ZM4.5 13.3c.705.088 1.39.284 2.072.478l.441.125c1.096.305 2.334.598 3.987.598 1.794 0 2.28-.223 2.528-.549.147-.193.276-.505.394-1.07.105-.502.188-1.124.295-1.93l.04-.3c.25-1.882.189-2.933-.068-3.497a.921.921 0 0 0-.442-.48c-.208-.104-.52-.174-.997-.174H11c-.686 0-1.295-.577-1.206-1.336.023-.192.05-.39.076-.586.065-.488.13-.97.13-1.328 0-.809-.144-1.15-.288-1.316-.137-.158-.402-.304-1.048-.378C8.357 1.521 8 1.793 8 2.25v.5c0 1.922-.978 3.128-1.933 3.825a5.831 5.831 0 0 1-1.567.81ZM2.75 6.5h-1a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h1a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z"></path>
        </svg>
    </button>
    <button class="dislike-btn" onclick="submitFeedbackForm(0)">
        <svg aria-hidden="true" focusable="false" class="" viewBox="0 0 16 16" width="16" height="16" fill="currentColor" style="display:inline-block;user-select:none;vertical-align:text-bottom;overflow:visible">
            <path d="M7.083 15.986c-.763-.087-1.499-.295-2.011-.884-.504-.581-.655-1.378-.655-2.299 0-.468.087-1.12.157-1.638l.015-.112H3.167c-.603 0-1.174-.086-1.669-.334a2.415 2.415 0 0 1-1.136-1.2c-.454-.998-.438-2.447-.188-4.316l.04-.306C.32 4.108.41 3.424.526 2.864c.132-.63.316-1.209.669-1.672C1.947.205 3.211.053 4.917.053c1.848 0 3.234.332 4.388.652l.474.133c.658.187 1.201.341 1.726.415a1.75 1.75 0 0 1 1.662-1.2h1c.966 0 1.75.784 1.75 1.75v7.5a1.75 1.75 0 0 1-1.75 1.75h-1a1.75 1.75 0 0 1-1.514-.872c-.259.105-.59.268-.919.508-.671.491-1.317 1.285-1.317 2.614v.5c0 1.201-.994 2.336-2.334 2.183Zm4.334-13.232c-.706-.089-1.39-.284-2.072-.479l-.441-.125c-1.096-.304-2.335-.597-3.987-.597-1.794 0-2.28.222-2.529.548-.147.193-.275.505-.393 1.07-.105.502-.188 1.124-.295 1.93l-.04.3c-.25 1.882-.19 2.933.067 3.497a.923.923 0 0 0 .443.48c.208.104.52.175.997.175h1.75c.685 0 1.295.577 1.205 1.335-.022.192-.049.39-.075.586-.066.488-.13.97-.13 1.329 0 .808.144 1.15.288 1.316.137.157.401.303 1.048.377.307.035.664-.237.664-.693v-.5c0-1.922.978-3.127 1.932-3.825a5.878 5.878 0 0 1 1.568-.809Zm1.75 6.798h1a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25h-1a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25Z"></path>
        </svg>
    </button>
</p>

<div class="expand-feedback-content" id="expandContentLike">
    <ul style="text-align:center">
        <li>Thank you! We received your feedback.</li>
        <li>If you have any comments, fill in <a href='https://www.espressif.com/en/company/documents/documentation_feedback?docId=4287&sections=General Purpose Timer (GPTimer) (api-reference/peripherals/gptimer)&version=esp32 latest (master)'>Espressif Documentation Feedback Form</a>.</li>
    </ul>
</div>

<div class="expand-feedback-content" id="expandContent">
    <ul style="text-align:center">
        <li>We value your feedback.</li>
        <li>Let us know how we can improve this page by filling in <a href='https://www.espressif.com/en/company/documents/documentation_feedback?docId=4287&sections=General Purpose Timer (GPTimer) (api-reference/peripherals/gptimer)&version=esp32 latest (master)'>Espressif Documentation Feedback Form</a>.</li>
    </ul>
</div>

<br>


             </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="gpio.html" class="btn btn-neutral float-left" title="GPIO &amp; RTC GPIO" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="i2c.html" class="btn btn-neutral float-right" title="Inter-Integrated Circuit (I2C)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016 - 2025, Espressif Systems (Shanghai) Co., Ltd.</p>
  </div>

  <ul class="footer">
        <li>
	    
            
            Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/espressif/sphinx_idf_theme">theme</a>  based on <a href="https://github.com/readthedocs/sphinx_rtd_theme">Read the Docs Sphinx Theme</a>.
         </li>
    <li class="footer-aside">
        <a href="../../esp-idf-en-latest.zip"> Download HTML</a>
    </li>

  </ul> 

</footer>
        </div>
      </div>
    </section>
  </div>

  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>