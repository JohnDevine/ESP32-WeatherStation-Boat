# SystemMetrics Library for ESP32

![Version](https://img.shields.io/badge/Version-1.0.0-brightgreen)
![ESP-IDF](https://img.shields.io/badge/ESP--IDF-v5.0+-blue)
![License](https://img.shields.io/badge/License-MIT-yellow)

## Overview

SystemMetrics is a comprehensive system monitoring and telemetry library for ESP32 microcontrollers. It provides a unified interface for accessing 39 different system metrics ranging from CPU performance to network connectivity, hardware status, and power management.

**Author:** john.h.devine@gmail.com  
**Version:** 1.0.0  
**Release Date:** September 2025

## Features

- **39 System Metrics** organized into logical categories
- **Human-Readable Outputs** in standard string format
- **Comprehensive Error Handling** with descriptive messages
- **Hardware Compatibility** detection for different ESP32 variants
- **Persistent Counters** for boots and crashes
- **Memory Efficient** with minimal resource usage
- **ESP-IDF Integration** with standard logging and APIs

## üìã Recommended Development Workflow

**IMPORTANT**: Always follow this documentation-first approach to prevent integration errors and save debugging time.

### **Phase 1: Documentation Review** üîç
Before writing any code, thoroughly review the SystemMetrics documentation:

```
"Please review the SystemMetrics library documentation and create comprehensive references including:
- Complete API reference with exact parameters
- Metric ID mapping table (all 39 metrics)
- Response format examples 
- Error codes and handling
- Integration examples
- Common gotchas and troubleshooting"
```

**Why This Matters:**
- ‚úÖ Prevents metric ID mapping errors
- ‚úÖ Avoids status code mismatches (`'ok'` vs `'success'`)
- ‚úÖ Ensures proper initialization order
- ‚úÖ Identifies unsupported metrics early
- ‚úÖ Creates reusable reference material

### **Phase 2: Systematic Implementation** üîß
Use the documented specifications to implement features correctly:

1. **Start with Core Integration**
   ```c
   // Initialize in correct order
   ESP_ERROR_CHECK(nvs_flash_init());
   system_metrics_init();
   ```

2. **Test One Metric at a Time**
   ```c
   // Verify specific metrics work
   ESP_LOGI("TEST", "Boot count: %s", get_system_metric(METRIC_BOOT_COUNT));
   ```

3. **Use Exact API Specifications**
   ```javascript
   // Use documented metric IDs and status codes
   if (data.status === 'ok') {  // Not 'success'!
       element.textContent = data.value;
   }
   ```

### **Phase 3: Validation & Testing** ‚úÖ
Verify implementation against documentation:

```
"Cross-check the implementation against the documented API:
- Are metric IDs exactly as specified?
- Does error handling match documented behavior?
- Are all edge cases covered?
- Does the response format match expectations?"
```

### **Phase 4: Documentation Updates** üìù
Update documentation with any discoveries or improvements made during implementation.

### **üö® Anti-Pattern: Implementation-First**
‚ùå **Don't do this:**
```
"Implement a metrics dashboard" 
‚Üí Leads to: wrong IDs, status mismatches, debugging cycles
```

‚úÖ **Do this instead:**
```
"First document the SystemMetrics API completely, then implement the dashboard using those specifications"
‚Üí Results in: accurate implementation, fewer bugs, maintainable code
```

### **Example Documentation-First Request**
```
"I want to add a system metrics dashboard to my ESP32 web interface. Before writing any code, please:

1. Review the SystemMetrics library header file
2. Create a complete metric ID reference table (0-38)
3. Document the exact JSON API response format
4. Identify initialization dependencies (NVS, etc.)
5. List common integration mistakes to avoid
6. Provide working JavaScript integration examples

Then use that documentation to implement the dashboard correctly."
```

This approach prevents errors like:
- Metric ID 33 vs 34 for boot count
- `"success"` vs `"ok"` status codes  
- Missing NVS initialization
- Incorrect enum counting

## Quick Start

```c
#include "SystemMetrics.h"

void app_main() {
    // Initialize NVS first (required for persistent metrics)
    esp_err_t ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        ESP_ERROR_CHECK(nvs_flash_erase());
        ret = nvs_flash_init();
    }
    ESP_ERROR_CHECK(ret);
    
    // Initialize SystemMetrics library
    if (!system_metrics_init()) {
        ESP_LOGE(TAG, "Failed to initialize SystemMetrics library");
        return;
    }
    
    // Read a specific metric
    const char* free_heap = get_system_metric(METRIC_FREE_HEAP);
    printf("Free heap: %s\n", free_heap);
    
    // Check for errors
    if (get_metric_error() != METRIC_OK) {
        printf("Error reading metric: %d\n", get_metric_error());
    }
}
```

## ‚ö†Ô∏è Important: Boot Count Behavior

The **Boot Count** metric (`METRIC_BOOT_COUNT`) requires special attention for proper operation:

### **Initialization Requirement**
- **MUST call `system_metrics_init()`** during application startup
- **MUST initialize NVS** before calling `system_metrics_init()`
- **Boot count is incremented ONLY during initialization**

### **Automatic Behavior**
```c
// During system_metrics_init():
uint32_t boot_count = 0;
nvs_get_blob(handle, "boot_count", &boot_count, &size);  // Read current count
boot_count++;                                            // Increment by 1
nvs_set_blob(handle, "boot_count", &boot_count, &size); // Save back to NVS
nvs_commit(handle);                                      // Commit to flash
```

### **When Boot Count Updates**
‚úÖ **Incremented on:**
- Power-on reset
- Watchdog reset  
- Software reset (`esp_restart()`)
- Panic/exception reset
- External reset pin

‚ùå **NOT incremented on:**
- Wake from deep sleep (uses same boot session)
- Wake from light sleep (not a reset)
- If `system_metrics_init()` is never called

### **Best Practice Integration**
```c
void app_main() {
    // 1. Initialize NVS storage first
    ESP_ERROR_CHECK(nvs_flash_init());
    
    // 2. Initialize SystemMetrics IMMEDIATELY after NVS
    //    (before any optional components that might be bypassed)
    if (!system_metrics_init()) {
        ESP_LOGW(TAG, "SystemMetrics init failed - boot count won't update");
    }
    
    // 3. Continue with other initialization...
    wifi_init();
    web_server_init();
    // etc...
}
```

### Troubleshooting Boot Count
| Problem | Cause | Solution |
|---------|-------|----------|
| Shows "ERROR: Boot count not available" | NVS not initialized | Call `nvs_flash_init()` before `system_metrics_init()` |
| Shows "ERROR: NVS not available" | SystemMetrics not initialized | Call `system_metrics_init()` in `app_main()` |
| Count never increases | SystemMetrics init not called | Add `system_metrics_init()` to startup sequence |
| Count resets to 0 | NVS partition erased | Normal after flash erase or partition corruption |

## üö® Common Integration Mistakes

### **Mistake 1: Wrong Metric IDs**
```javascript
// ‚ùå WRONG - Guessed or miscounted IDs
const badMapping = {
    'boot-count': 33,  // Actually 34!
    'wifi-rssi': 11,   // Actually 13!
};

// ‚úÖ CORRECT - Use exact IDs from reference table
const goodMapping = {
    'boot-count': 34,  // METRIC_BOOT_COUNT
    'wifi-rssi': 13,   // METRIC_WIFI_RSSI
};
```

### **Mistake 2: Wrong Status Check**
```javascript
// ‚ùå WRONG - Checking for 'success'
if (data.status === 'success') { ... }

// ‚úÖ CORRECT - Server returns 'ok'
if (data.status === 'ok') { ... }
```

### **Mistake 3: Missing NVS Initialization**
```c
// ‚ùå WRONG - SystemMetrics without NVS
void app_main() {
    system_metrics_init();  // Will fail!
}

// ‚úÖ CORRECT - NVS first, then SystemMetrics
void app_main() {
    ESP_ERROR_CHECK(nvs_flash_init());
    system_metrics_init();
}
```

### **Mistake 4: Not Handling Unavailable Metrics**
```javascript
// ‚ùå WRONG - Assumes all metrics work
element.textContent = data.value;

// ‚úÖ CORRECT - Handle error states
if (data.status === 'ok') {
    element.textContent = data.value;
} else {
    element.textContent = getUnavailableMessage(metricId);
}
```

## üîß Debugging Tips

### **Enable Debug Logging**
```c
// Add to web server metric handler
ESP_LOGI("API", "Metric %d request: %s", metric_id, get_system_metric(metric_id));

// Add to JavaScript
console.log('Fetching metric', metricId, 'got response:', data);
```

### **Test Individual Metrics**
```c
// Test in main() during development
ESP_LOGI("TEST", "Boot count: %s", get_system_metric(METRIC_BOOT_COUNT));
ESP_LOGI("TEST", "CPU freq: %s", get_system_metric(METRIC_CPU_FREQUENCY));
```

### **Verify Metric Count**
```c
// Ensure your IDs don't exceed the limit
ESP_LOGI("INFO", "Total metrics available: %d", METRIC_COUNT);
```

## üìù Development Checklist

When integrating SystemMetrics:

- [ ] ‚úÖ Called `nvs_flash_init()` before `system_metrics_init()`
- [ ] ‚úÖ Used exact metric IDs from reference table
- [ ] ‚úÖ Check for `status === 'ok'` not `'success'`
- [ ] ‚úÖ Handle error responses gracefully
- [ ] ‚úÖ Test boot count increments across resets
- [ ] ‚úÖ Add appropriate unavailable messages for unsupported metrics
- [ ] ‚úÖ Enable debug logging during development
- [ ] ‚úÖ Verify metric IDs don't exceed `METRIC_COUNT`

## API Reference

### Core Functions

| Function | Description | Return Type |
|----------|-------------|-------------|
| `bool system_metrics_init(void)` | Initialize the metrics library | `bool` - Success or failure |
| `const char* get_system_metric(system_metric_t metric)` | Get the value of the specified metric | `const char*` - Null-terminated string |
| `const char* get_metric_description(system_metric_t metric)` | Get a description of the metric | `const char*` - Null-terminated string |
| `metric_error_t get_metric_error(void)` | Get the last error code | `metric_error_t` - Error code enum |
| `bool update_boot_count(uint32_t new_count)` | Update the boot count value in NVS | `bool` - Success or failure |
| `bool get_boot_count(uint32_t *count)` | Get the raw boot count value as a number | `bool` - Success or failure |

### Complete Metric ID Reference

**‚ö†Ô∏è IMPORTANT**: Use these exact IDs when calling `get_system_metric()` or building web APIs.

| Metric ID | Enum Name | Description | Example Output |
|-----------|-----------|-------------|----------------|
| 0 | `METRIC_CPU_FREQUENCY` | CPU clock frequency | "240 MHz" |
| 1 | `METRIC_CPU_TEMPERATURE` | CPU die temperature | "42.5¬∞C" |
| 2 | `METRIC_FREE_HEAP` | Available heap memory | "123456 bytes" |
| 3 | `METRIC_MIN_FREE_HEAP` | Minimum free heap since boot | "98765 bytes" |
| 4 | `METRIC_UPTIME` | Time since boot | "1d 12h 34m 56s" |
| 5 | `METRIC_RESET_REASON` | Reason for last reset | "Power On" |
| 6 | `METRIC_TASK_RUNTIME_STATS` | Task runtime statistics | "3 tasks active" |
| 7 | `METRIC_TASK_PRIORITY` | Current task priority | "5" |
| 8 | `METRIC_POWER_MODE` | Current power mode | "Performance" |
| 9 | `METRIC_LIGHT_SLEEP_DURATION` | Time spent in light sleep | "12345 ms" |
| 10 | `METRIC_DEEP_SLEEP_DURATION` | Time spent in deep sleep | "60000 ms" |
| 11 | `METRIC_VDD33_VOLTAGE` | 3.3V rail voltage | "3.28 V" |
| 12 | `METRIC_CURRENT_CONSUMPTION` | Current consumption | "ERROR: Requires external hardware" |
| 13 | `METRIC_WIFI_RSSI` | WiFi signal strength | "-67 dBm" |
| 14 | `METRIC_WIFI_TX_POWER` | WiFi transmit power | "20 dBm" |
| 15 | `METRIC_WIFI_TX_RX_BYTES` | WiFi data transferred | "TX: 1.2 MB, RX: 3.4 MB" |
| 16 | `METRIC_IP_ADDRESS` | Device IP address | "192.168.1.100" |
| 17 | `METRIC_WIFI_STATUS` | WiFi connection status | "Connected" |
| 18 | `METRIC_NETWORK_SPEED` | Network connection speed | "72.2 Mbps" |
| 19 | `METRIC_BT_BLE_RSSI` | Bluetooth/BLE signal strength | "ERROR: BT not connected" |
| 20 | `METRIC_BT_BLE_CONNECTED_DEVICES` | Connected BT devices | "0 devices" |
| 21 | `METRIC_FLASH_USAGE` | Flash memory usage | "1.2 MB / 4.0 MB (30%)" |
| 22 | `METRIC_FLASH_RW_OPERATIONS` | Flash read/write operations | "Read: 123, Write: 45" |
| 23 | `METRIC_SPIFFS_USAGE` | SPIFFS filesystem usage | "512 KB / 1.0 MB (50%)" |
| 24 | `METRIC_I2C_BUS_ERRORS` | I2C bus error count | "0 errors" |
| 25 | `METRIC_SPI_PERFORMANCE` | SPI transfer performance | "20 MHz" |
| 26 | `METRIC_GPIO_STATUS` | GPIO pin status | "GPIO22: HIGH, GPIO23: LOW" |
| 27 | `METRIC_CHIP_ID` | Unique chip identifier | "0x1A2B3C4D" |
| 28 | `METRIC_MAC_ADDRESS` | WiFi/BT MAC address | "AA:BB:CC:DD:EE:FF" |
| 29 | `METRIC_FLASH_SIZE` | Flash memory size | "4 MB" |
| 30 | `METRIC_CHIP_REVISION` | Chip silicon revision | "v1.2" |
| 31 | `METRIC_CORE_COUNT` | Number of CPU cores | "2 cores" |
| 32 | `METRIC_TASK_COUNT` | Number of active FreeRTOS tasks | "8 tasks" |
| 33 | `METRIC_TASK_STACK_HWM` | Task stack high water mark | "1024 bytes" |
| **34** | `METRIC_BOOT_COUNT` | **Number of device boots** | **"42 boots"** |
| 35 | `METRIC_CRASH_COUNT` | Number of crash resets | "3 crashes" |
| 36 | `METRIC_OTA_UPDATE_STATUS` | OTA update status | "Up to date (running app)" |
| 37 | `METRIC_LAST_UPDATE_TIME` | Time of last update | "2025-09-17 13:45:30" |
| 38 | `METRIC_APP_SPECIFIC_TIMERS` | Application timers | "App timer: 3600 seconds" |

### Web API Integration

If you're building a web interface with HTTP endpoints, use this pattern:

#### HTTP Endpoint Implementation
```c
// GET /get_metric?id=34 (for boot count)
esp_err_t get_metric_handler(httpd_req_t *req) {
    // Parse ?id=X parameter
    char query_str[128];
    httpd_req_get_url_query_str(req, query_str, sizeof(query_str));
    
    char metric_id_str[16];
    httpd_query_key_value(query_str, "id", metric_id_str, sizeof(metric_id_str));
    
    int metric_id = atoi(metric_id_str);
    const char* value = get_system_metric((system_metric_t)metric_id);
    metric_error_t error = get_metric_error();
    
    // JSON Response Format (IMPORTANT!)
    char response[256];
    if (error == METRIC_OK) {
        snprintf(response, sizeof(response), 
                "{\"id\":%d,\"value\":\"%s\",\"status\":\"ok\"}", 
                metric_id, value);
    } else {
        snprintf(response, sizeof(response), 
                "{\"id\":%d,\"value\":\"unavailable\",\"status\":\"error\"}", 
                metric_id);
    }
    
    httpd_resp_set_type(req, "application/json");
    httpd_resp_send(req, response, strlen(response));
    return ESP_OK;
}
```

#### JavaScript Integration
```javascript
// Correct metric mappings (use exact IDs from table above!)
const metricMappings = {
    'boot-count-element': 34,    // METRIC_BOOT_COUNT
    'cpu-freq-element': 0,       // METRIC_CPU_FREQUENCY  
    'free-heap-element': 2,      // METRIC_FREE_HEAP
    // ... add others as needed
};

// Fetch metrics with proper status checking
async function fetchMetric(elementId, metricId) {
    try {
        const response = await fetch(`/get_metric?id=${metricId}`);
        const data = await response.json();
        
        const element = document.getElementById(elementId);
        if (data.status === 'ok') {           // Check for 'ok', not 'success'!
            element.textContent = data.value;
        } else {
            element.textContent = 'Unavailable';
        }
    } catch (error) {
        console.error(`Error fetching metric ${metricId}:`, error);
    }
}
```

### Error Codes

| Error Code | Description |
|------------|-------------|
| `METRIC_OK` | Success - No error |
| `METRIC_ERROR_INVALID_ID` | Invalid metric ID |
| `METRIC_ERROR_NOT_AVAILABLE` | Metric not available (e.g., WiFi not connected) |
| `METRIC_ERROR_NOT_SUPPORTED` | Metric not supported by this hardware |
| `METRIC_ERROR_HARDWARE_FAULT` | Hardware sensor fault |
| `METRIC_ERROR_BUFFER_TOO_SMALL` | Output buffer too small |

## Complete Metrics Catalog

### Performance Metrics

| Metric ID | Description | Example Output | Notes |
|-----------|-------------|----------------|-------|
| `METRIC_CPU_FREQUENCY` | CPU clock frequency | "240 MHz" | Default frequency on most ESP32 models |
| `METRIC_CPU_TEMPERATURE` | CPU die temperature | "42.5¬∞C" | Only on ESP32-S2/S3/C2/C3/C6 |
| `METRIC_FREE_HEAP` | Available heap memory | "123456 bytes" | Current free heap |
| `METRIC_MIN_FREE_HEAP` | Minimum free heap since boot | "98765 bytes" | Low water mark |
| `METRIC_UPTIME` | Time since boot | "1d 12h 34m 56s" | Days, hours, minutes, seconds |
| `METRIC_RESET_REASON` | Reason for last reset | "Power On" | E.g. Power on, watchdog, panic |
| `METRIC_TASK_RUNTIME_STATS` | Task runtime statistics | "3 tasks active" | Number of FreeRTOS tasks |
| `METRIC_TASK_PRIORITY` | Current task priority | "5" | FreeRTOS priority level |
| `METRIC_TASK_COUNT` | Total number of tasks | "8 tasks" | Running FreeRTOS tasks |
| `METRIC_TASK_HWM` | Task stack high water mark | "1024 bytes" | Stack usage peak |

### Power Management

| Metric ID | Description | Example Output | Notes |
|-----------|-------------|----------------|-------|
| `METRIC_POWER_MODE` | Current power mode | "Performance" | Performance, balanced, or power saving |
| `METRIC_LIGHT_SLEEP_DURATION` | Time spent in light sleep | "12345 ms" | Milliseconds in light sleep |
| `METRIC_DEEP_SLEEP_DURATION` | Time spent in deep sleep | "60000 ms" | Milliseconds in deep sleep |
| `METRIC_VDD33_VOLTAGE` | 3.3V rail voltage | "3.28 V" | Requires ADC calibration |
| `METRIC_CURRENT_CONSUMPTION` | Current consumption | "ERROR: Requires external hardware" | Needs external measurement |

### Connectivity

| Metric ID | Description | Example Output | Notes |
|-----------|-------------|----------------|-------|
| `METRIC_WIFI_RSSI` | WiFi signal strength | "-67 dBm" | Requires WiFi connection |
| `METRIC_WIFI_TX_POWER` | WiFi transmit power | "20 dBm" | Current TX power setting |
| `METRIC_WIFI_TX_RX_BYTES` | WiFi data transferred | "TX: 1.2 MB, RX: 3.4 MB" | Since last reset |
| `METRIC_IP_ADDRESS` | Device IP address | "192.168.1.100" | Primary network interface |
| `METRIC_WIFI_STATUS` | WiFi connection status | "Connected" | Connected, connecting, disconnected |
| `METRIC_NETWORK_SPEED` | Network connection speed | "72.2 Mbps" | Link speed |
| `METRIC_BT_BLE_RSSI` | Bluetooth/BLE signal strength | "ERROR: BT not connected" | Requires BT connection |
| `METRIC_BT_BLE_CONNECTED_DEVICES` | Connected BT devices | "0 devices" | Number of connected devices |

### Storage

| Metric ID | Description | Example Output | Notes |
|-----------|-------------|----------------|-------|
| `METRIC_FLASH_USAGE` | Flash memory usage | "1.2 MB / 4.0 MB (30%)" | Used / total (percentage) |
| `METRIC_FLASH_RW_OPERATIONS` | Flash read/write operations | "Read: 123, Write: 45" | Since boot |
| `METRIC_SPIFFS_USAGE` | SPIFFS filesystem usage | "512 KB / 1.0 MB (50%)" | Used / total (percentage) |

### Hardware

| Metric ID | Description | Example Output | Notes |
|-----------|-------------|----------------|-------|
| `METRIC_I2C_BUS_ERRORS` | I2C bus error count | "0 errors" | Bus errors since boot |
| `METRIC_SPI_PERFORMANCE` | SPI transfer performance | "20 MHz" | Current clock speed |
| `METRIC_GPIO_STATUS` | GPIO pin status | "GPIO22: HIGH, GPIO23: LOW" | Key GPIO status |
| `METRIC_CHIP_ID` | Unique chip identifier | "0x1A2B3C4D" | Factory-programmed ID |
| `METRIC_MAC_ADDRESS` | WiFi/BT MAC address | "AA:BB:CC:DD:EE:FF" | Factory-assigned |
| `METRIC_FLASH_SIZE` | Flash memory size | "4 MB" | Total flash capacity |
| `METRIC_CHIP_REVISION` | Chip silicon revision | "v1.2" | Hardware revision |
| `METRIC_CORE_COUNT` | Number of CPU cores | "2 cores" | Processor cores |

### Application

| Metric ID | Description | Example Output | Notes |
|-----------|-------------|----------------|-------|
| `METRIC_BOOT_COUNT` | Number of device boots | "42 boots" | **Requires `system_metrics_init()` call** ‚ö†Ô∏è |
| `METRIC_CRASH_COUNT` | Number of crash resets | "3 crashes" | Detected by reset reason |
| `METRIC_OTA_UPDATE_STATUS` | OTA update status | "Up to date (running app)" | Current partition info |
| `METRIC_LAST_UPDATE_TIME` | Time of last update | "2025-09-17 13:45:30" | Stored in NVS |
| `METRIC_APP_SPECIFIC_TIMERS` | Application timers | "App timer: 3600 seconds" | Custom application timers |

## NVS Storage

SystemMetrics uses Non-Volatile Storage (NVS) for persistent counters and metrics.

### Partition & Namespace

- **Partition**: Default NVS partition (`nvs`, typically 24KB at offset 0x9000)
- **Namespace**: `"metrics"`
- **Access Mode**: `NVS_READWRITE`

### Stored Values

| Key | Type | Description |
|-----|------|-------------|
| `boot_count` | `uint32_t` | Number of system boots (incremented at initialization) |
| `crash_count` | `uint32_t` | Crash detection counter (incremented on crash resets) |
| `last_update` | `uint64_t` | Timestamp of last system update (microseconds) |

### NVS Initialization

```c
// System initialization will automatically:
// 1. Initialize NVS flash
esp_err_t ret = nvs_flash_init();

// 2. Open "metrics" namespace
ret = nvs_open("metrics", NVS_READWRITE, &metrics_nvs_handle);

// 3. Update boot counter
uint32_t boot_count = 0;
nvs_get_blob(metrics_nvs_handle, "boot_count", &boot_count, &required_size);
boot_count++;
nvs_set_blob(metrics_nvs_handle, "boot_count", &boot_count, sizeof(boot_count));
nvs_commit(metrics_nvs_handle);
```

## Hardware Compatibility

### ESP32 Variants

| Feature | ESP32 | ESP32-S2 | ESP32-S3 | ESP32-C2 | ESP32-C3 | ESP32-C6 |
|---------|-------|----------|----------|----------|----------|----------|
| CPU Temperature | ‚ùå | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |
| Bluetooth | ‚úÖ | ‚ùå | ‚úÖ | ‚ùå | ‚úÖ | ‚úÖ |
| Full Metrics | ‚ùå | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |

The library uses conditional compilation to handle hardware differences:

```c
#if defined(CONFIG_IDF_TARGET_ESP32S2) \
 || defined(CONFIG_IDF_TARGET_ESP32S3) \
 || defined(CONFIG_IDF_TARGET_ESP32C2) \
 || defined(CONFIG_IDF_TARGET_ESP32C3) \
 || defined(CONFIG_IDF_TARGET_ESP32C6)
    // Temperature sensor supported
#else
    // Original ESP32 - no built-in temperature sensor
    return "ERROR: Temperature sensor not available on ESP32";
#endif
```

## Error Handling

SystemMetrics uses a robust error reporting system:

```c
const char* temp = get_system_metric(METRIC_CPU_TEMPERATURE);
metric_error_t err = get_metric_error();

switch (err) {
    case METRIC_OK:
        printf("Temperature: %s\n", temp);
        break;
    case METRIC_ERROR_NOT_SUPPORTED:
        printf("This ESP32 model doesn't support temperature sensing\n");
        break;
    case METRIC_ERROR_HARDWARE_FAULT:
        printf("Temperature sensor hardware fault\n");
        break;
    default:
        printf("Unknown error: %d\n", err);
        break;
}
```

## Memory Usage

- **Flash**: ~10KB code size
- **RAM**: ~1KB static allocation
- **NVS**: ~16 bytes for persistent counters

## Integration

### PlatformIO

In your `platformio.ini`:

```ini
lib_deps =
    SystemMetrics
```

### ESP-IDF Component

Include as a component in your ESP-IDF project structure.

## Version History

### v1.0.0 (September 2025)
- Initial release
- 39 system metrics implemented
- Full ESP32 family compatibility
- Persistent boot and crash counters

## License

MIT License

## Author

john.h.devine@gmail.com