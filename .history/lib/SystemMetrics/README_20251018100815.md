# SystemMetrics Library for ESP32

![Version](https://img.shields.io/badge/Version-1.0.0-brightgreen)
![ESP-IDF](https://img.shields.io/badge/ESP--IDF-v5.0+-blue)
![License](https://img.shields.io/badge/License-MIT-yellow)

## Overview

SystemMetrics is a comprehensive system monitoring and telemetry library for ESP32 microcontrollers. It provides a unified interface for accessing 39 different system metrics ranging from CPU performance to network connectivity, hardware status, and power management.

**Author:** john.h.devine@gmail.com  
**Version:** 1.0.0  
**Release Date:** September 2025

## Features

- **39 System Metrics** organized into logical categories
- **Human-Readable Outputs** in standard string format
- **Comprehensive Error Handling** with descriptive messages
- **Hardware Compatibility** detection for different ESP32 variants
- **Persistent Counters** for boots and crashes
- **Memory Efficient** with minimal resource usage
- **ESP-IDF Integration** with standard logging and APIs

## Quick Start

```c
#include "SystemMetrics.h"

void app_main() {
    // Initialize NVS first (required for persistent metrics)
    esp_err_t ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        ESP_ERROR_CHECK(nvs_flash_erase());
        ret = nvs_flash_init();
    }
    ESP_ERROR_CHECK(ret);
    
    // Initialize SystemMetrics library
    if (!system_metrics_init()) {
        ESP_LOGE(TAG, "Failed to initialize SystemMetrics library");
        return;
    }
    
    // Read a specific metric
    const char* free_heap = get_system_metric(METRIC_FREE_HEAP);
    printf("Free heap: %s\n", free_heap);
    
    // Check for errors
    if (get_metric_error() != METRIC_OK) {
        printf("Error reading metric: %d\n", get_metric_error());
    }
}
```

## ⚠️ Important: Boot Count Behavior

The **Boot Count** metric (`METRIC_BOOT_COUNT`) requires special attention for proper operation:

### **Initialization Requirement**
- **MUST call `system_metrics_init()`** during application startup
- **MUST initialize NVS** before calling `system_metrics_init()`
- **Boot count is incremented ONLY during initialization**

### **Automatic Behavior**
```c
// During system_metrics_init():
uint32_t boot_count = 0;
nvs_get_blob(handle, "boot_count", &boot_count, &size);  // Read current count
boot_count++;                                            // Increment by 1
nvs_set_blob(handle, "boot_count", &boot_count, &size); // Save back to NVS
nvs_commit(handle);                                      // Commit to flash
```

### **When Boot Count Updates**
✅ **Incremented on:**
- Power-on reset
- Watchdog reset  
- Software reset (`esp_restart()`)
- Panic/exception reset
- External reset pin

❌ **NOT incremented on:**
- Wake from deep sleep (uses same boot session)
- Wake from light sleep (not a reset)
- If `system_metrics_init()` is never called

### **Best Practice Integration**
```c
void app_main() {
    // 1. Initialize NVS storage first
    ESP_ERROR_CHECK(nvs_flash_init());
    
    // 2. Initialize SystemMetrics IMMEDIATELY after NVS
    //    (before any optional components that might be bypassed)
    if (!system_metrics_init()) {
        ESP_LOGW(TAG, "SystemMetrics init failed - boot count won't update");
    }
    
    // 3. Continue with other initialization...
    wifi_init();
    web_server_init();
    // etc...
}
```

### **Troubleshooting Boot Count**
| Problem | Cause | Solution |
|---------|-------|----------|
| Shows "ERROR: Boot count not available" | NVS not initialized | Call `nvs_flash_init()` before `system_metrics_init()` |
| Shows "ERROR: NVS not available" | SystemMetrics not initialized | Call `system_metrics_init()` in `app_main()` |
| Count never increases | SystemMetrics init not called | Add `system_metrics_init()` to startup sequence |
| Count resets to 0 | NVS partition erased | Normal after flash erase or partition corruption |

## API Reference

### Core Functions

| Function | Description | Return Type |
|----------|-------------|-------------|
| `bool system_metrics_init(void)` | Initialize the metrics library | `bool` - Success or failure |
| `const char* get_system_metric(system_metric_t metric)` | Get the value of the specified metric | `const char*` - Null-terminated string |
| `const char* get_metric_description(system_metric_t metric)` | Get a description of the metric | `const char*` - Null-terminated string |
| `metric_error_t get_metric_error(void)` | Get the last error code | `metric_error_t` - Error code enum |

### Error Codes

| Error Code | Description |
|------------|-------------|
| `METRIC_OK` | Success - No error |
| `METRIC_ERROR_INVALID_ID` | Invalid metric ID |
| `METRIC_ERROR_NOT_AVAILABLE` | Metric not available (e.g., WiFi not connected) |
| `METRIC_ERROR_NOT_SUPPORTED` | Metric not supported by this hardware |
| `METRIC_ERROR_HARDWARE_FAULT` | Hardware sensor fault |
| `METRIC_ERROR_BUFFER_TOO_SMALL` | Output buffer too small |

## Complete Metrics Catalog

### Performance Metrics

| Metric ID | Description | Example Output | Notes |
|-----------|-------------|----------------|-------|
| `METRIC_CPU_FREQUENCY` | CPU clock frequency | "240 MHz" | Default frequency on most ESP32 models |
| `METRIC_CPU_TEMPERATURE` | CPU die temperature | "42.5°C" | Only on ESP32-S2/S3/C2/C3/C6 |
| `METRIC_FREE_HEAP` | Available heap memory | "123456 bytes" | Current free heap |
| `METRIC_MIN_FREE_HEAP` | Minimum free heap since boot | "98765 bytes" | Low water mark |
| `METRIC_UPTIME` | Time since boot | "1d 12h 34m 56s" | Days, hours, minutes, seconds |
| `METRIC_RESET_REASON` | Reason for last reset | "Power On" | E.g. Power on, watchdog, panic |
| `METRIC_TASK_RUNTIME_STATS` | Task runtime statistics | "3 tasks active" | Number of FreeRTOS tasks |
| `METRIC_TASK_PRIORITY` | Current task priority | "5" | FreeRTOS priority level |
| `METRIC_TASK_COUNT` | Total number of tasks | "8 tasks" | Running FreeRTOS tasks |
| `METRIC_TASK_HWM` | Task stack high water mark | "1024 bytes" | Stack usage peak |

### Power Management

| Metric ID | Description | Example Output | Notes |
|-----------|-------------|----------------|-------|
| `METRIC_POWER_MODE` | Current power mode | "Performance" | Performance, balanced, or power saving |
| `METRIC_LIGHT_SLEEP_DURATION` | Time spent in light sleep | "12345 ms" | Milliseconds in light sleep |
| `METRIC_DEEP_SLEEP_DURATION` | Time spent in deep sleep | "60000 ms" | Milliseconds in deep sleep |
| `METRIC_VDD33_VOLTAGE` | 3.3V rail voltage | "3.28 V" | Requires ADC calibration |
| `METRIC_CURRENT_CONSUMPTION` | Current consumption | "ERROR: Requires external hardware" | Needs external measurement |

### Connectivity

| Metric ID | Description | Example Output | Notes |
|-----------|-------------|----------------|-------|
| `METRIC_WIFI_RSSI` | WiFi signal strength | "-67 dBm" | Requires WiFi connection |
| `METRIC_WIFI_TX_POWER` | WiFi transmit power | "20 dBm" | Current TX power setting |
| `METRIC_WIFI_TX_RX_BYTES` | WiFi data transferred | "TX: 1.2 MB, RX: 3.4 MB" | Since last reset |
| `METRIC_IP_ADDRESS` | Device IP address | "192.168.1.100" | Primary network interface |
| `METRIC_WIFI_STATUS` | WiFi connection status | "Connected" | Connected, connecting, disconnected |
| `METRIC_NETWORK_SPEED` | Network connection speed | "72.2 Mbps" | Link speed |
| `METRIC_BT_BLE_RSSI` | Bluetooth/BLE signal strength | "ERROR: BT not connected" | Requires BT connection |
| `METRIC_BT_BLE_CONNECTED_DEVICES` | Connected BT devices | "0 devices" | Number of connected devices |

### Storage

| Metric ID | Description | Example Output | Notes |
|-----------|-------------|----------------|-------|
| `METRIC_FLASH_USAGE` | Flash memory usage | "1.2 MB / 4.0 MB (30%)" | Used / total (percentage) |
| `METRIC_FLASH_RW_OPERATIONS` | Flash read/write operations | "Read: 123, Write: 45" | Since boot |
| `METRIC_SPIFFS_USAGE` | SPIFFS filesystem usage | "512 KB / 1.0 MB (50%)" | Used / total (percentage) |

### Hardware

| Metric ID | Description | Example Output | Notes |
|-----------|-------------|----------------|-------|
| `METRIC_I2C_BUS_ERRORS` | I2C bus error count | "0 errors" | Bus errors since boot |
| `METRIC_SPI_PERFORMANCE` | SPI transfer performance | "20 MHz" | Current clock speed |
| `METRIC_GPIO_STATUS` | GPIO pin status | "GPIO22: HIGH, GPIO23: LOW" | Key GPIO status |
| `METRIC_CHIP_ID` | Unique chip identifier | "0x1A2B3C4D" | Factory-programmed ID |
| `METRIC_MAC_ADDRESS` | WiFi/BT MAC address | "AA:BB:CC:DD:EE:FF" | Factory-assigned |
| `METRIC_FLASH_SIZE` | Flash memory size | "4 MB" | Total flash capacity |
| `METRIC_CHIP_REVISION` | Chip silicon revision | "v1.2" | Hardware revision |
| `METRIC_CORE_COUNT` | Number of CPU cores | "2 cores" | Processor cores |

### Application

| Metric ID | Description | Example Output | Notes |
|-----------|-------------|----------------|-------|
| `METRIC_BOOT_COUNT` | Number of device boots | "42 boots" | Stored in NVS |
| `METRIC_CRASH_COUNT` | Number of crash resets | "3 crashes" | Detected by reset reason |
| `METRIC_OTA_UPDATE_STATUS` | OTA update status | "Up to date (running app)" | Current partition info |
| `METRIC_LAST_UPDATE_TIME` | Time of last update | "2025-09-17 13:45:30" | Stored in NVS |
| `METRIC_APP_SPECIFIC_TIMERS` | Application timers | "App timer: 3600 seconds" | Custom application timers |

## NVS Storage

SystemMetrics uses Non-Volatile Storage (NVS) for persistent counters and metrics.

### Partition & Namespace

- **Partition**: Default NVS partition (`nvs`, typically 24KB at offset 0x9000)
- **Namespace**: `"metrics"`
- **Access Mode**: `NVS_READWRITE`

### Stored Values

| Key | Type | Description |
|-----|------|-------------|
| `boot_count` | `uint32_t` | Number of system boots (incremented at initialization) |
| `crash_count` | `uint32_t` | Crash detection counter (incremented on crash resets) |
| `last_update` | `uint64_t` | Timestamp of last system update (microseconds) |

### NVS Initialization

```c
// System initialization will automatically:
// 1. Initialize NVS flash
esp_err_t ret = nvs_flash_init();

// 2. Open "metrics" namespace
ret = nvs_open("metrics", NVS_READWRITE, &metrics_nvs_handle);

// 3. Update boot counter
uint32_t boot_count = 0;
nvs_get_blob(metrics_nvs_handle, "boot_count", &boot_count, &required_size);
boot_count++;
nvs_set_blob(metrics_nvs_handle, "boot_count", &boot_count, sizeof(boot_count));
nvs_commit(metrics_nvs_handle);
```

## Hardware Compatibility

### ESP32 Variants

| Feature | ESP32 | ESP32-S2 | ESP32-S3 | ESP32-C2 | ESP32-C3 | ESP32-C6 |
|---------|-------|----------|----------|----------|----------|----------|
| CPU Temperature | ❌ | ✅ | ✅ | ✅ | ✅ | ✅ |
| Bluetooth | ✅ | ❌ | ✅ | ❌ | ✅ | ✅ |
| Full Metrics | ❌ | ✅ | ✅ | ✅ | ✅ | ✅ |

The library uses conditional compilation to handle hardware differences:

```c
#if defined(CONFIG_IDF_TARGET_ESP32S2) \
 || defined(CONFIG_IDF_TARGET_ESP32S3) \
 || defined(CONFIG_IDF_TARGET_ESP32C2) \
 || defined(CONFIG_IDF_TARGET_ESP32C3) \
 || defined(CONFIG_IDF_TARGET_ESP32C6)
    // Temperature sensor supported
#else
    // Original ESP32 - no built-in temperature sensor
    return "ERROR: Temperature sensor not available on ESP32";
#endif
```

## Error Handling

SystemMetrics uses a robust error reporting system:

```c
const char* temp = get_system_metric(METRIC_CPU_TEMPERATURE);
metric_error_t err = get_metric_error();

switch (err) {
    case METRIC_OK:
        printf("Temperature: %s\n", temp);
        break;
    case METRIC_ERROR_NOT_SUPPORTED:
        printf("This ESP32 model doesn't support temperature sensing\n");
        break;
    case METRIC_ERROR_HARDWARE_FAULT:
        printf("Temperature sensor hardware fault\n");
        break;
    default:
        printf("Unknown error: %d\n", err);
        break;
}
```

## Memory Usage

- **Flash**: ~10KB code size
- **RAM**: ~1KB static allocation
- **NVS**: ~16 bytes for persistent counters

## Integration

### PlatformIO

In your `platformio.ini`:

```ini
lib_deps =
    SystemMetrics
```

### ESP-IDF Component

Include as a component in your ESP-IDF project structure.

## Version History

### v1.0.0 (September 2025)
- Initial release
- 39 system metrics implemented
- Full ESP32 family compatibility
- Persistent boot and crash counters

## License

MIT License

## Author

john.h.devine@gmail.com